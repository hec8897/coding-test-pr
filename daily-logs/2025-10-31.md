# 2025-10-31 (금) 학습 일지

## 📚 오늘의 목표

- ✅ Day 4: 그리디 알고리즘 학습 시작
- ✅ 그리디 개념 체계적으로 정리
- ✅ 그리디 문제 풀이 (구명보트)

---

## 🎯 Day 4: 실전 문제 (Lv.2) - 그리디 편

### 📖 그리디 알고리즘 개념 정리

#### 핵심 개념

- **"매 순간 최선의 선택을 하면, 전체적으로도 최선의 결과를 얻을 수 있다"**
- 직관적이고 빠른 알고리즘 (O(n log n))
- 대부분 정렬과 함께 사용

#### 실생활 예시

1. **거스름돈**: 가장 큰 동전부터 사용
2. **회의실 배정**: 빨리 끝나는 회의부터 선택

#### 그리디 vs DFS

| 구분     | 그리디         | DFS            |
| -------- | -------------- | -------------- |
| 사고방식 | 지금 당장 최선 | 모든 경우 탐색 |
| 속도     | ⚡ O(n log n)  | 🐌 O(2ⁿ)       |
| 난이도   | 😊 쉬움        | 😵 어려움      |

#### 3가지 패턴

1. **정렬 + 양쪽 포인터** (Two Pointers)
2. **정렬 + 순회**
3. **정렬 + 스택**

---

## ✅ 문제 풀이

### 1️⃣ [Lv.2] 구명보트

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 25분  
**상태**: ✅ 완료

#### 📌 문제 요약

- 구명보트로 모든 사람을 구출
- 보트는 최대 2명, 무게 제한 있음
- 최소 보트 개수 구하기

#### 💡 핵심 아이디어

**그리디 전략**: 가장 무거운 사람 + 가장 가벼운 사람을 먼저 태워보기

**투 포인터 (Two Pointers)**:

- `left`: 가장 가벼운 사람
- `right`: 가장 무거운 사람
- 둘이 태울 수 있으면 같이, 안 되면 무거운 사람만

#### 🔑 알고리즘

```
1. 배열을 오름차순 정렬
2. 양쪽 포인터 초기화 (left=0, right=length-1)
3. while (left <= right):
   - 가벼운 + 무거운 <= limit?
     YES: 둘 다 태우기 (left++, right--)
     NO: 무거운 사람만 (right--)
   - boats++
4. boats 반환
```

#### 💻 코드

```typescript
function solution(people: number[], limit: number): number {
  people.sort((a, b) => a - b);
  let boats = 0;
  let left = 0;
  let right = people.length - 1;

  while (left <= right) {
    if (people[left] + people[right] <= limit) {
      left++;
      right--;
    } else {
      right--;
    }
    boats++;
  }

  return boats;
}
```

#### ⏰ 시간 복잡도

- 정렬: O(n log n)
- 투 포인터: O(n)
- **전체: O(n log n)**

#### 💾 공간 복잡도

- O(1) (추가 배열 없음)

#### 📚 배운 점

1. **그리디 + 투 포인터 조합**이 매우 효과적
2. 정렬하면 양쪽 끝에서 접근하는 전략이 명확해짐
3. "가장 어려운 것(무거운 사람)부터 처리"하는 사고방식
4. DFS보다 훨씬 직관적이고 빠름!

#### 🤔 실수한 점

1. 처음에 `<` 대신 `<=`를 써야 하는 걸 놓침
2. `return 0` 대신 `return boats`를 써야 함

#### ✨ 개선 포인트

- 불필요한 변수 `peoples` 제거 가능 (`sort()`는 원본 수정)
- 조건문 논리를 명확히 이해

---

### 2️⃣ [Lv.2] 큰 수 만들기

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 30분  
**상태**: ✅ 완료

#### 📌 문제 요약

- 숫자 문자열에서 k개를 제거해서 가장 큰 수 만들기
- 예: "1924", k=2 → "94"

#### 💡 핵심 아이디어

**그리디 전략**: "앞자리가 클수록 큰 수다!"

- 현재 숫자보다 작은 숫자를 제거
- 스택으로 이전 숫자 관리

#### 🔑 알고리즘

```
1. 스택 초기화
2. 숫자를 하나씩 확인:
   - while: 스택 top < 현재 숫자 && 제거 가능
     → 스택에서 제거
   - 현재 숫자를 스택에 추가
3. 남은 제거 개수 처리 (뒤에서 제거)
4. 스택을 문자열로 변환
```

#### 💻 코드

```typescript
function solution(number: string, k: number): string {
  const stack: string[] = [];
  let removeCount = 0;

  for (const num of number) {
    while (
      stack.length > 0 &&
      stack[stack.length - 1] < num &&
      removeCount < k
    ) {
      stack.pop();
      removeCount++;
    }
    stack.push(num);
  }

  // 남은 제거 개수 처리
  while (removeCount < k) {
    stack.pop();
    removeCount++;
  }

  return stack.join("");
}
```

#### ⏰ 시간 복잡도

- 각 숫자는 최대 1번 push, 1번 pop: O(n)
- **전체: O(n)**

#### 💾 공간 복잡도

- 스택에 최대 n개: O(n)

#### 📚 배운 점

1. **그리디 + 스택 조합**: 이전 선택을 취소할 수 있는 그리디
2. **while 문의 중요성**: 작은 값이 여러 개일 때 모두 제거
3. **특수 케이스 처리**: 내림차순("9876")은 뒤에서 제거
4. **3가지 조건 체크**:
   - `stack.length > 0`: 스택이 비어있지 않음
   - `stack[stack.length - 1] < num`: 작은 값 발견
   - `removeCount < k`: 아직 제거 가능
5. **문자열 비교**: `'1' < '9'` 가능 (형변환 불필요)

#### 🤔 실수한 점

1. 처음에 `number[]` 타입 사용 → `string[]`이 더 간단
2. `stack[stack.length] - 1` 인덱스 오류 → `stack[stack.length - 1]`
3. 남은 제거 처리를 잊음 → while 문으로 뒤에서 제거

#### ✨ 핵심 깨달음

- **removeCount < k 조건**: k개를 이미 제거했으면 더 이상 제거 안 함
- **남은 제거 처리**: for 문에서 못 지운 개수를 반드시 처리
- **while의 의미**: 조건이 만족하는 **동안** 계속 실행

---

### 3️⃣ [Lv.1] 체육복 (복습)

**플랫폼**: 프로그래머스  
**난이도**: Lv.1  
**소요 시간**: 10분  
**상태**: ✅ 완료 (복습)

#### 📌 문제 요약

- 도난당한 학생, 여벌 체육복 있는 학생
- 앞뒤 학생에게만 빌려줄 수 있음
- 최대한 많은 학생이 수업을 듣게 하기

#### 💡 핵심 아이디어

**그리디 전략**: "앞번호부터 순서대로 처리하며 바로 빌려주기!"

**상태 배열 관리**:

- 0: 체육복 없음 (도난)
- 1: 체육복 1개 (정상)
- 2: 체육복 2개 (여벌)

#### 💻 코드

```typescript
function solution(n: number, lost: number[], reserve: number[]): number {
  const students = Array(n).fill(1);
  lost.forEach((l) => students[l - 1]--);
  reserve.forEach((r) => students[r - 1]++);

  for (let i = 0; i < n; i++) {
    if (students[i] === 0) {
      if (i > 0 && students[i - 1] === 2) {
        students[i]++;
        students[i - 1]--;
      } else if (i < n - 1 && students[i + 1] === 2) {
        students[i]++;
        students[i + 1]--;
      }
    }
  }

  return students.filter((s) => s > 0).length;
}
```

#### ⏰ 시간 복잡도

- 전체: O(n)

#### 💾 공간 복잡도

- 상태 배열: O(n)

#### 📚 배운 점

1. **그리디 + 순회 패턴**: 앞부터 순서대로 처리
2. **상태 배열 관리**: 증감 연산으로 효율적 관리
3. **else if 활용**: 앞번호 우선 처리

#### 🤔 실수한 점

1. `students[0]` → `students[i]` (잘못된 인덱스)
2. `while` → `if` (1번만 실행)
3. `while` → `else if` (우선순위)

---

## 📝 추가 활동

### 📚 그리디 개념 문서화

- `algorithms/그리디.md` 생성
- 실생활 예시, 3가지 패턴, 문제 풀이 전략 정리
- 나중에 복습하기 쉽도록 체계적으로 정리

---

## 🎓 오늘의 핵심 개념

### ⭐ 그리디 알고리즘 (Greedy Algorithm)

- 매 순간 최선의 선택
- 정렬 + 선택 전략
- 직관적이고 빠름

### ⭐ 투 포인터 (Two Pointers)

- 양쪽 끝에서 시작
- 조건에 따라 포인터 이동
- 배열 문제에서 자주 활용

### ⭐ 정렬 활용

- 대부분의 그리디는 정렬부터 시작
- 오름차순/내림차순 전략적 선택

---

## 💭 오늘의 회고

### 잘한 점

- ✅ 그리디 개념을 체계적으로 정리
- ✅ 실생활 예시로 이해도 향상
- ✅ DFS보다 쉽고 빠르다는 것을 체감
- ✅ 투 포인터 패턴 습득

### 어려웠던 점

- ⚠️ 처음에 조건문 부등호 실수 (`<` vs `<=`)
- ⚠️ 반환값 실수 (`return 0`)

### 개선할 점

- 문제 풀기 전에 조건을 더 꼼꼼히 확인하기
- 테스트 케이스를 직접 손으로 추적해보기

---

## 📊 학습 통계

- **오늘 푼 문제**: 3문제 (신규 2 + 복습 1)
- **총 누적 문제**: 29문제
- **연속 학습일**: 4일 🔥🔥🔥🔥
- **학습 시간**: 약 2.5시간
- **주요 개념**: 그리디, 투 포인터, 스택, 정렬, 순회, 상태관리

---

## 🎯 다음 학습 계획

### Session 2 (14:00-16:00)

- [ ] 그리디 문제 2~3개 더 풀기
- [ ] 구현 문제 도전
- [ ] 개념별 복습 시작

### Day 4 목표

- [x] 그리디 개념 학습 ✅
- [x] 그리디 문제 2개 풀기 (2/3) ✅
  - [x] 구명보트 ✅
  - [x] 큰 수 만들기 ✅
- [ ] 그리디 문제 1개 더 (선택)
- [ ] 구현 문제 시작

---

## 🔗 관련 파일

- [구명보트 풀이](../programmers/lv2_구명보트/solution.ts)
- [구명보트 README](../programmers/lv2_구명보트/README.md)
- [큰 수 만들기 풀이](../programmers/lv2_큰_수_만들기/solution.ts)
- [큰 수 만들기 README](../programmers/lv2_큰_수_만들기/README.md)
- [체육복 복습](../programmers/lv1_체육복/복습.ts)
- [체육복 README](../programmers/lv1_체육복/README.md)
- [그리디 개념 정리](../algorithms/그리디.md)
- [단기 코테 준비 계획](../단기_코테_준비.md)

---

**오늘도 화이팅! 🚀**
