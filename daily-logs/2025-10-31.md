# 2025-10-31 (금) 학습 일지

## 📚 오늘의 목표

- ✅ Day 4: 그리디 알고리즘 학습 시작
- ✅ 그리디 개념 체계적으로 정리
- ✅ 그리디 문제 풀이 (구명보트, 큰 수 만들기)
- ✅ 재귀 개념 체계적으로 정리
- ✅ 재귀 패턴 연습 시작 (팩토리얼)
- ✅ 구현 문제 시작 (124 나라의 숫자)

---

## 🎯 Day 4: 실전 문제 (Lv.2) - 그리디 편

### 📖 그리디 알고리즘 개념 정리

#### 핵심 개념

- **"매 순간 최선의 선택을 하면, 전체적으로도 최선의 결과를 얻을 수 있다"**
- 직관적이고 빠른 알고리즘 (O(n log n))
- 대부분 정렬과 함께 사용

#### 실생활 예시

1. **거스름돈**: 가장 큰 동전부터 사용
2. **회의실 배정**: 빨리 끝나는 회의부터 선택

#### 그리디 vs DFS

| 구분     | 그리디         | DFS            |
| -------- | -------------- | -------------- |
| 사고방식 | 지금 당장 최선 | 모든 경우 탐색 |
| 속도     | ⚡ O(n log n)  | 🐌 O(2ⁿ)       |
| 난이도   | 😊 쉬움        | 😵 어려움      |

#### 3가지 패턴

1. **정렬 + 양쪽 포인터** (Two Pointers)
2. **정렬 + 순회**
3. **정렬 + 스택**

---

## ✅ 문제 풀이

### 1️⃣ [Lv.2] 구명보트

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 25분  
**상태**: ✅ 완료

#### 📌 문제 요약

- 구명보트로 모든 사람을 구출
- 보트는 최대 2명, 무게 제한 있음
- 최소 보트 개수 구하기

#### 💡 핵심 아이디어

**그리디 전략**: 가장 무거운 사람 + 가장 가벼운 사람을 먼저 태워보기

**투 포인터 (Two Pointers)**:

- `left`: 가장 가벼운 사람
- `right`: 가장 무거운 사람
- 둘이 태울 수 있으면 같이, 안 되면 무거운 사람만

#### 🔑 알고리즘

```
1. 배열을 오름차순 정렬
2. 양쪽 포인터 초기화 (left=0, right=length-1)
3. while (left <= right):
   - 가벼운 + 무거운 <= limit?
     YES: 둘 다 태우기 (left++, right--)
     NO: 무거운 사람만 (right--)
   - boats++
4. boats 반환
```

#### 💻 코드

```typescript
function solution(people: number[], limit: number): number {
  people.sort((a, b) => a - b);
  let boats = 0;
  let left = 0;
  let right = people.length - 1;

  while (left <= right) {
    if (people[left] + people[right] <= limit) {
      left++;
      right--;
    } else {
      right--;
    }
    boats++;
  }

  return boats;
}
```

#### ⏰ 시간 복잡도

- 정렬: O(n log n)
- 투 포인터: O(n)
- **전체: O(n log n)**

#### 💾 공간 복잡도

- O(1) (추가 배열 없음)

#### 📚 배운 점

1. **그리디 + 투 포인터 조합**이 매우 효과적
2. 정렬하면 양쪽 끝에서 접근하는 전략이 명확해짐
3. "가장 어려운 것(무거운 사람)부터 처리"하는 사고방식
4. DFS보다 훨씬 직관적이고 빠름!

#### 🤔 실수한 점

1. 처음에 `<` 대신 `<=`를 써야 하는 걸 놓침
2. `return 0` 대신 `return boats`를 써야 함

#### ✨ 개선 포인트

- 불필요한 변수 `peoples` 제거 가능 (`sort()`는 원본 수정)
- 조건문 논리를 명확히 이해

---

### 2️⃣ [Lv.2] 큰 수 만들기

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 30분  
**상태**: ✅ 완료

#### 📌 문제 요약

- 숫자 문자열에서 k개를 제거해서 가장 큰 수 만들기
- 예: "1924", k=2 → "94"

#### 💡 핵심 아이디어

**그리디 전략**: "앞자리가 클수록 큰 수다!"

- 현재 숫자보다 작은 숫자를 제거
- 스택으로 이전 숫자 관리

#### 🔑 알고리즘

```
1. 스택 초기화
2. 숫자를 하나씩 확인:
   - while: 스택 top < 현재 숫자 && 제거 가능
     → 스택에서 제거
   - 현재 숫자를 스택에 추가
3. 남은 제거 개수 처리 (뒤에서 제거)
4. 스택을 문자열로 변환
```

#### 💻 코드

```typescript
function solution(number: string, k: number): string {
  const stack: string[] = [];
  let removeCount = 0;

  for (const num of number) {
    while (
      stack.length > 0 &&
      stack[stack.length - 1] < num &&
      removeCount < k
    ) {
      stack.pop();
      removeCount++;
    }
    stack.push(num);
  }

  // 남은 제거 개수 처리
  while (removeCount < k) {
    stack.pop();
    removeCount++;
  }

  return stack.join("");
}
```

#### ⏰ 시간 복잡도

- 각 숫자는 최대 1번 push, 1번 pop: O(n)
- **전체: O(n)**

#### 💾 공간 복잡도

- 스택에 최대 n개: O(n)

#### 📚 배운 점

1. **그리디 + 스택 조합**: 이전 선택을 취소할 수 있는 그리디
2. **while 문의 중요성**: 작은 값이 여러 개일 때 모두 제거
3. **특수 케이스 처리**: 내림차순("9876")은 뒤에서 제거
4. **3가지 조건 체크**:
   - `stack.length > 0`: 스택이 비어있지 않음
   - `stack[stack.length - 1] < num`: 작은 값 발견
   - `removeCount < k`: 아직 제거 가능
5. **문자열 비교**: `'1' < '9'` 가능 (형변환 불필요)

#### 🤔 실수한 점

1. 처음에 `number[]` 타입 사용 → `string[]`이 더 간단
2. `stack[stack.length] - 1` 인덱스 오류 → `stack[stack.length - 1]`
3. 남은 제거 처리를 잊음 → while 문으로 뒤에서 제거

#### ✨ 핵심 깨달음

- **removeCount < k 조건**: k개를 이미 제거했으면 더 이상 제거 안 함
- **남은 제거 처리**: for 문에서 못 지운 개수를 반드시 처리
- **while의 의미**: 조건이 만족하는 **동안** 계속 실행

---

### 3️⃣ [Lv.1] 체육복 (복습)

**플랫폼**: 프로그래머스  
**난이도**: Lv.1  
**소요 시간**: 10분  
**상태**: ✅ 완료 (복습)

#### 📌 문제 요약

- 도난당한 학생, 여벌 체육복 있는 학생
- 앞뒤 학생에게만 빌려줄 수 있음
- 최대한 많은 학생이 수업을 듣게 하기

#### 💡 핵심 아이디어

**그리디 전략**: "앞번호부터 순서대로 처리하며 바로 빌려주기!"

**상태 배열 관리**:

- 0: 체육복 없음 (도난)
- 1: 체육복 1개 (정상)
- 2: 체육복 2개 (여벌)

#### 💻 코드

```typescript
function solution(n: number, lost: number[], reserve: number[]): number {
  const students = Array(n).fill(1);
  lost.forEach((l) => students[l - 1]--);
  reserve.forEach((r) => students[r - 1]++);

  for (let i = 0; i < n; i++) {
    if (students[i] === 0) {
      if (i > 0 && students[i - 1] === 2) {
        students[i]++;
        students[i - 1]--;
      } else if (i < n - 1 && students[i + 1] === 2) {
        students[i]++;
        students[i + 1]--;
      }
    }
  }

  return students.filter((s) => s > 0).length;
}
```

#### ⏰ 시간 복잡도

- 전체: O(n)

#### 💾 공간 복잡도

- 상태 배열: O(n)

#### 📚 배운 점

1. **그리디 + 순회 패턴**: 앞부터 순서대로 처리
2. **상태 배열 관리**: 증감 연산으로 효율적 관리
3. **else if 활용**: 앞번호 우선 처리

#### 🤔 실수한 점

1. `students[0]` → `students[i]` (잘못된 인덱스)
2. `while` → `if` (1번만 실행)
3. `while` → `else if` (우선순위)

---

---

### 4️⃣ [Lv.0] 팩토리얼 (재귀 연습)

**플랫폼**: 프로그래머스  
**난이도**: Lv.0  
**소요 시간**: 10분  
**상태**: ✅ 완료 (재귀 패턴 연습)

#### 📌 문제 요약

- 정수 n이 주어질 때 n! 구하기
- 재귀로 구현

#### 💡 핵심 아이디어

**Simple Recursion (단순 재귀)**:
- 자기 자신을 호출하되 1개의 경로만 있음
- 기저 조건: n = 0 또는 1
- 재귀 호출: n * factorial(n-1)

#### 💻 코드

```typescript
function solution(n: number): number {
  if (n === 0 || n === 1) return 1;
  return n * solution(n - 1);
}
```

#### 📚 배운 점

1. **기저 조건의 중요성**: n=0 처리를 빼먹으면 stack overflow
2. **재귀의 기본 패턴**: 종료 조건 + 자기 호출
3. **Call Stack 이해**: 5! = 5 × 4 × 3 × 2 × 1

#### 🤔 실수한 점

1. 처음에 `if (n === 1)` 만 작성 → n=0일 때 무한 재귀
2. 수학적 정의 확인: 0! = 1

---

### 5️⃣ [Lv.2] 124 나라의 숫자

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 20분  
**상태**: ✅ 완료

#### 📌 문제 요약

- 1, 2, 4만 사용하는 나라
- 10진수 n을 124 나라 숫자로 변환
- 예: 1→1, 2→2, 3→4, 4→11, 10→41

#### 💡 핵심 아이디어

**진법 변환 + 패턴 찾기**:
- 3진법과 비슷하지만 0이 없음
- 나머지 0 → '4' (특별 처리!)
- 나머지 1 → '1'
- 나머지 2 → '2'

**특별 처리**:
- 나머지가 0이면 `n = n / 3 - 1` (-1이 핵심!)

#### 🔑 알고리즘

```
1. while (n > 0):
   - remainder = n % 3
   - if remainder === 0:
       result = '4' + result
       n = n / 3 - 1
   - else:
       result = remainder + result
       n = Math.floor(n / 3)
2. return result
```

#### 💻 코드

```typescript
function solution(n: number): string {
  let result = "";
  while (n > 0) {
    const remainder = n % 3;
    if (remainder === 0) {
      result = "4" + result;
      n = n / 3 - 1;
    } else {
      result = remainder + result;
      n = Math.floor(n / 3);
    }
  }
  return result;
}
```

#### ⏰ 시간 복잡도

- O(log n) - n을 3으로 계속 나눔

#### 💾 공간 복잡도

- O(log n) - 결과 문자열 길이

#### 📚 배운 점

1. **While 루프의 조건 변수**: n이 조건이자 변하는 값
2. **패턴 찾기**: 예시를 나열해서 규칙 발견
3. **특수 케이스 처리**: 나머지 0일 때 -1
4. **진법 변환 원리**: 3진법과의 유사점/차이점
5. **변수의 이중 역할**: while 조건 + 반복마다 갱신

#### 🤔 질문했던 점

1. **"회전이 쌓일 때마다 n이 누적되나?"**
   - ❌ 누적이 아니라 **교체**
   - n은 점점 작아짐 (10 → 3 → 0)
   - result는 쌓임 ("" → "1" → "41")

2. **"n = n / 3 - 1이 변수 할당?"**
   - ✅ 맞음! 오른쪽 계산 후 왼쪽에 저장
   - 기존 n값을 읽어서 → 계산 → 새 값으로 교체

3. **"while의 n이 변수 역할?"**
   - ✅ 정확히 이해!
   - `while (n > 0)`: 조건
   - `n = n / 3 - 1`: 값 변경
   - n이 0이 되면 while 종료

#### ✨ 핵심 깨달음

- **n은 교체 (줄어듦)**: 10 → 3 → 0
- **result는 누적 (쌓임)**: "" → "1" → "41"
- **While 조건 변수**: 조건이자 변하는 값

---

---

### 6️⃣ [Lv.2] 타겟 넘버 (분기 재귀 개념)

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 15분 (개념 이해)  
**상태**: 🔍 개념 학습 완료

#### 📌 문제 요약

- 숫자를 +/- 하여 target 만들기
- 방법의 개수 구하기

#### 💡 핵심 아이디어

**Branching Recursion (분기 재귀)**:
- 각 단계에서 2가지 선택 (+ 또는 -)
- 트리 구조로 모든 경로 탐색
- 개수의 합으로 결과 반환

#### 📚 배운 점

1. **return 1, 0의 의미**: 개수를 세는 문제!
   - 성공하면 1 (1가지 방법 카운트)
   - 실패하면 0 (카운트 안 함)
   - 모든 경로의 1과 0을 더하면 총 개수

2. **분기 재귀 구조**:
   ```typescript
   const plusWay = dfs(index + 1, sum + num);
   const minusWay = dfs(index + 1, sum - num);
   return plusWay + minusWay;  // 개수의 합!
   ```

3. **재귀의 본질**: 반복이 중요!
   - 자기 자신을 반복 호출
   - 문제를 작게 만들어 반복
   - 종료 조건까지 반복

---

### 7️⃣ [Lv.0] 조합 (백트래킹)

**플랫폼**: 프로그래머스  
**난이도**: Lv.0  
**소요 시간**: 20분  
**상태**: ✅ 완료

#### 📌 문제 요약

- n개 중 r개를 뽑는 조합의 개수
- 예: [1,2,3,4]에서 2개 → 6가지

#### 💡 핵심 아이디어

**Backtracking (백트래킹)**:
- "선택 → 진행 → 취소(되돌아가기)"
- push → 재귀 → pop

#### 🔑 알고리즘

```typescript
function dfs(start: number, current: number[]) {
  // 1. 종료 조건
  if (current.length === r) {
    count++;
    return;
  }
  
  // 2. 선택과 취소
  for (let i = start; i < arr.length; i++) {
    current.push(arr[i]);      // 선택
    dfs(i + 1, current);       // 진행
    current.pop();             // 취소 (백트래킹!)
  }
}
```

#### 💻 코드

```typescript
function solution(arr: number[], r: number): number {
  let count = 0;
  
  function dfs(start: number, current: number[]) {
    if (current.length === r) {
      count++;
      return;
    }
    
    for (let i = start; i < arr.length; i++) {
      current.push(arr[i]);
      dfs(i + 1, current);
      current.pop();
    }
  }
  
  dfs(0, []);
  return count;
}
```

#### ⏰ 시간 복잡도

- O(nCr) - 가능한 조합의 개수만큼

#### 💾 공간 복잡도

- O(r) - Call Stack 깊이

#### 📚 배운 점

1. **pop()의 역할**: 상태를 되돌리기 위해
   - 다른 선택지를 시도하기 위해
   - 배열을 재사용하기 위해
   - 깨끗한 상태에서 다시 시작

2. **백트래킹 패턴**:
   ```
   push(선택) → 재귀(진행) → pop(취소)
   ```

3. **start 파라미터**: 중복 방지
   - i + 1부터 시작 → 이전 원소 선택 안 함
   - [1,2]와 [2,1]을 같은 것으로 처리

4. **재귀 3가지 패턴 정리**:
   - Simple: 1번 호출 (팩토리얼)
   - Branching: 2번 호출 (타겟 넘버)
   - Backtracking: push/pop (조합)

#### 🤔 질문했던 점

**Q: "왜 pop()을 하나요?"**

A: 다른 선택지를 시도하기 위해 상태를 되돌리는 거예요!
- [1] → push(2) → [1,2] ✨
- [1,2] → pop(2) → [1] ⏪ 복구
- [1] → push(3) → [1,3] ✨

pop() = 백트래킹의 핵심!

---

## 🔁 복습 세션 (저녁)

### 복습 1: [Lv.1] 폰켓몬 (해시/Set)

**소요 시간**: 5분  
**상태**: ✅ 완료

#### 핵심 코드
```typescript
const uniq = new Set(nums);
return Math.min(nums.length / 2, uniq.size);
```

#### 배운 점
- Set으로 중복 제거
- Math.min으로 선택 가능 수와 종류 수 비교
- 매우 간결한 코드 (2줄!)

---

### 복습 2: [Lv.1] 같은 숫자는 싫어 (스택)

**소요 시간**: 10분  
**상태**: ✅ 완료

#### 핵심 코드
```typescript
const stack: number[] = [];
for (const num of arr) {
  if (stack.length === 0 || num !== stack[stack.length - 1]) {
    stack.push(num);
  }
}
return stack;
```

#### 실수한 점
- 처음에 `else { stack.pop() }` 추가함 → 틀림!
- 같으면 그냥 무시하면 됨 (pop 필요 없음)

#### 배운 점
- 스택의 마지막 원소와 비교
- 다르면 push, 같으면 무시
- 불필요한 else 블록 제거

---

### 복습 3: [Lv.1] K번째수 (정렬)

**소요 시간**: 8분  
**상태**: ✅ 완료

#### 핵심 코드
```typescript
for (const [i, j, k] of commands) {
  answer.push(array.slice(i - 1, j).sort((a, b) => a - b)[k - 1]);
}
```

#### 배운 점
- 메서드 체이닝: slice → sort → []
- 인덱스 변환: i-1, k-1 (1부터 시작 → 0부터 시작)
- 한 줄로 간결하게 표현 가능

---

### 복습 4: [Lv.2] 타겟 넘버 (분기 재귀 구현)

**소요 시간**: 15분  
**상태**: ✅ 완료

#### 핵심 코드
```typescript
function dfs(index: number, sum: number): number {
  if (index === numbers.length) {
    return sum === target ? 1 : 0;
  }
  
  const plus = dfs(index + 1, sum + numbers[index]);
  const minus = dfs(index + 1, sum - numbers[index]);
  
  return plus + minus;
}
```

#### 배운 점
- 개념 이해 후 직접 구현 성공!
- 종료 조건: 1 또는 0 반환 (개수 세기)
- 재귀 호출: 2번 (+ 경로, - 경로)
- 결과 합산: plusWay + minusWay
- 분기 재귀 패턴 완전히 이해

---

## 📝 추가 활동

### 📚 그리디 개념 문서화

- `algorithms/그리디.md` 생성
- 실생활 예시, 3가지 패턴, 문제 풀이 전략 정리
- 나중에 복습하기 쉽도록 체계적으로 정리

### 📚 재귀 개념 문서화

- `algorithms/재귀.md` 생성
- 실생활 예시 (마트료시카, 계단 오르기)
- 2가지 필수 요소 (기저 조건, 재귀 호출)
- 3가지 재귀 패턴 (Simple, Branching, Backtracking)
- Call Stack 시각화
- 재귀 vs 반복문 비교
- 디버깅 팁

---

## 🎓 오늘의 핵심 개념

### ⭐ 그리디 알고리즘 (Greedy Algorithm)

- 매 순간 최선의 선택
- 정렬 + 선택 전략
- 직관적이고 빠름

### ⭐ 투 포인터 (Two Pointers)

- 양쪽 끝에서 시작
- 조건에 따라 포인터 이동
- 배열 문제에서 자주 활용

### ⭐ 정렬 활용

- 대부분의 그리디는 정렬부터 시작
- 오름차순/내림차순 전략적 선택

---

## 💭 오늘의 회고

### 잘한 점

- ✅ 그리디 개념을 체계적으로 정리
- ✅ 실생활 예시로 이해도 향상
- ✅ DFS보다 쉽고 빠르다는 것을 체감
- ✅ 투 포인터 패턴 습득
- ✅ 재귀 3가지 패턴 모두 마스터
- ✅ 복습 세션으로 핵심 개념 재확인
- ✅ 타겟 넘버 직접 구현 성공!

### 어려웠던 점

- ⚠️ 처음에 조건문 부등호 실수 (`<` vs `<=`)
- ⚠️ 반환값 실수 (`return 0`)

### 개선할 점

- 문제 풀기 전에 조건을 더 꼼꼼히 확인하기
- 테스트 케이스를 직접 손으로 추적해보기

---

## 📊 학습 통계

- **오늘 푼 문제**: 11문제 (신규 4 + 복습 5 + 재귀 연습 2)
- **총 누적 문제**: 31문제
- **연속 학습일**: 4일 🔥🔥🔥🔥
- **학습 시간**: 약 6시간
- **주요 개념**: 그리디, 투 포인터, 스택, 정렬, 순회, 상태관리, 재귀(3가지 패턴), 백트래킹, 진법 변환, while 루프, 패턴 찾기, 해시, Set

---

## 🎯 다음 학습 계획

### Day 4 목표 달성 현황

- [x] 그리디 개념 학습 ✅
- [x] 그리디 문제 2개 풀기 ✅
  - [x] 구명보트 ✅
  - [x] 큰 수 만들기 ✅
- [x] 체육복 복습 ✅
- [x] 재귀 개념 정리 ✅
- [x] 재귀 3가지 패턴 학습 ✅
  - [x] Simple Recursion (팩토리얼) ✅
  - [x] Branching Recursion (타겟 넘버 개념) ✅
  - [x] Backtracking (조합 구현) ✅
- [x] 구현 문제 (124 나라의 숫자) ✅

**🎉 Day 4 완료! 재귀 3가지 패턴 모두 마스터!**

### 다음 세션

- [ ] Day 5: 전체 복습 및 약점 보완
- [ ] 문자열 처리 문제 도전
- [ ] 부족한 개념 재학습
- [ ] 더 많은 문제 복습

**🎯 복습의 중요성을 체감!** 여러 번 풀어보니 이해도가 높아짐!

---

## 🔗 관련 파일

- [구명보트 풀이](../programmers/lv2_구명보트/solution.ts)
- [구명보트 README](../programmers/lv2_구명보트/README.md)
- [큰 수 만들기 풀이](../programmers/lv2_큰_수_만들기/solution.ts)
- [큰 수 만들기 README](../programmers/lv2_큰_수_만들기/README.md)
- [체육복 복습](../programmers/lv1_체육복/복습.ts)
- [체육복 README](../programmers/lv1_체육복/README.md)
- [팩토리얼 재귀 풀이](../programmers/lv0_팩토리얼/복습_재귀.ts)
- [124 나라의 숫자 풀이](../programmers/lv2_124_나라의_숫자/solution.ts)
- [124 나라의 숫자 README](../programmers/lv2_124_나라의_숫자/README.md)
- [타겟 넘버 재귀 패턴](../programmers/lv2_타겟_넘버/복습2_재귀패턴.ts)
- [타겟 넘버 복습 (구현)](../programmers/lv2_타겟_넘버/복습3.ts)
- [폰켓몬 복습](../programmers/lv1_폰켓몬/복습.ts)
- [같은 숫자는 싫어 복습](../programmers/lv1_같은_숫자는_싫어/복습.ts)
- [K번째수 복습](../programmers/lv1_k번째수/복습.ts)
- [조합 풀이](../programmers/lv0_조합/solution.ts)
- [조합 README](../programmers/lv0_조합/README.md)
- [그리디 개념 정리](../algorithms/그리디.md)
- [재귀 개념 정리](../algorithms/재귀.md)
- [단기 코테 준비 계획](../단기_코테_준비.md)

---

**오늘도 화이팅! 🚀**
