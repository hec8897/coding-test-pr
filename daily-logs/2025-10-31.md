# 2025-10-31 (금) 학습 일지

## 📚 오늘의 목표

- ✅ Day 4: 그리디 알고리즘 학습 시작
- ✅ 그리디 개념 체계적으로 정리
- ✅ 그리디 문제 풀이 (구명보트)

---

## 🎯 Day 4: 실전 문제 (Lv.2) - 그리디 편

### 📖 그리디 알고리즘 개념 정리

#### 핵심 개념
- **"매 순간 최선의 선택을 하면, 전체적으로도 최선의 결과를 얻을 수 있다"**
- 직관적이고 빠른 알고리즘 (O(n log n))
- 대부분 정렬과 함께 사용

#### 실생활 예시
1. **거스름돈**: 가장 큰 동전부터 사용
2. **회의실 배정**: 빨리 끝나는 회의부터 선택

#### 그리디 vs DFS
| 구분 | 그리디 | DFS |
|------|--------|-----|
| 사고방식 | 지금 당장 최선 | 모든 경우 탐색 |
| 속도 | ⚡ O(n log n) | 🐌 O(2ⁿ) |
| 난이도 | 😊 쉬움 | 😵 어려움 |

#### 3가지 패턴
1. **정렬 + 양쪽 포인터** (Two Pointers)
2. **정렬 + 순회**
3. **정렬 + 스택**

---

## ✅ 문제 풀이

### 1️⃣ [Lv.2] 구명보트

**플랫폼**: 프로그래머스  
**난이도**: Lv.2  
**소요 시간**: 25분  
**상태**: ✅ 완료

#### 📌 문제 요약
- 구명보트로 모든 사람을 구출
- 보트는 최대 2명, 무게 제한 있음
- 최소 보트 개수 구하기

#### 💡 핵심 아이디어
**그리디 전략**: 가장 무거운 사람 + 가장 가벼운 사람을 먼저 태워보기

**투 포인터 (Two Pointers)**:
- `left`: 가장 가벼운 사람
- `right`: 가장 무거운 사람
- 둘이 태울 수 있으면 같이, 안 되면 무거운 사람만

#### 🔑 알고리즘
```
1. 배열을 오름차순 정렬
2. 양쪽 포인터 초기화 (left=0, right=length-1)
3. while (left <= right):
   - 가벼운 + 무거운 <= limit?
     YES: 둘 다 태우기 (left++, right--)
     NO: 무거운 사람만 (right--)
   - boats++
4. boats 반환
```

#### 💻 코드
```typescript
function solution(people: number[], limit: number): number {
  people.sort((a, b) => a - b);
  let boats = 0;
  let left = 0;
  let right = people.length - 1;

  while (left <= right) {
    if (people[left] + people[right] <= limit) {
      left++;
      right--;
    } else {
      right--;
    }
    boats++;
  }

  return boats;
}
```

#### ⏰ 시간 복잡도
- 정렬: O(n log n)
- 투 포인터: O(n)
- **전체: O(n log n)**

#### 💾 공간 복잡도
- O(1) (추가 배열 없음)

#### 📚 배운 점
1. **그리디 + 투 포인터 조합**이 매우 효과적
2. 정렬하면 양쪽 끝에서 접근하는 전략이 명확해짐
3. "가장 어려운 것(무거운 사람)부터 처리"하는 사고방식
4. DFS보다 훨씬 직관적이고 빠름!

#### 🤔 실수한 점
1. 처음에 `<` 대신 `<=`를 써야 하는 걸 놓침
2. `return 0` 대신 `return boats`를 써야 함

#### ✨ 개선 포인트
- 불필요한 변수 `peoples` 제거 가능 (`sort()`는 원본 수정)
- 조건문 논리를 명확히 이해

---

## 📝 추가 활동

### 📚 그리디 개념 문서화
- `algorithms/그리디.md` 생성
- 실생활 예시, 3가지 패턴, 문제 풀이 전략 정리
- 나중에 복습하기 쉽도록 체계적으로 정리

---

## 🎓 오늘의 핵심 개념

### ⭐ 그리디 알고리즘 (Greedy Algorithm)
- 매 순간 최선의 선택
- 정렬 + 선택 전략
- 직관적이고 빠름

### ⭐ 투 포인터 (Two Pointers)
- 양쪽 끝에서 시작
- 조건에 따라 포인터 이동
- 배열 문제에서 자주 활용

### ⭐ 정렬 활용
- 대부분의 그리디는 정렬부터 시작
- 오름차순/내림차순 전략적 선택

---

## 💭 오늘의 회고

### 잘한 점
- ✅ 그리디 개념을 체계적으로 정리
- ✅ 실생활 예시로 이해도 향상
- ✅ DFS보다 쉽고 빠르다는 것을 체감
- ✅ 투 포인터 패턴 습득

### 어려웠던 점
- ⚠️ 처음에 조건문 부등호 실수 (`<` vs `<=`)
- ⚠️ 반환값 실수 (`return 0`)

### 개선할 점
- 문제 풀기 전에 조건을 더 꼼꼼히 확인하기
- 테스트 케이스를 직접 손으로 추적해보기

---

## 📊 학습 통계

- **오늘 푼 문제**: 1문제
- **총 누적 문제**: 28문제
- **연속 학습일**: 4일 🔥🔥🔥🔥
- **학습 시간**: 약 2시간 (10:00-12:00 예정)
- **주요 개념**: 그리디, 투 포인터, 정렬

---

## 🎯 다음 학습 계획

### Session 2 (14:00-16:00)
- [ ] 그리디 문제 2~3개 더 풀기
- [ ] 구현 문제 도전
- [ ] 개념별 복습 시작

### Day 4 목표
- [x] 그리디 개념 학습 ✅
- [ ] 그리디 문제 3개 풀기 (1/3)
- [ ] 구현 문제 시작

---

## 🔗 관련 파일

- [구명보트 풀이](../programmers/lv2_구명보트/solution.ts)
- [구명보트 README](../programmers/lv2_구명보트/README.md)
- [그리디 개념 정리](../algorithms/그리디.md)
- [단기 코테 준비 계획](../단기_코테_준비.md)

---

**오늘도 화이팅! 🚀**

