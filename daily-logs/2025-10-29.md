# 학습 일지 - 2025년 10월 29일 (수)

## 📅 학습 세션

### 오늘의 목표

Day 1 복습 후 Day 2 시작!

### 복습한 문제

- ✅ [프로그래머스 Lv.1] 완주하지 못한 선수 - 복습 ⭐⭐⭐
- ✅ [프로그래머스 Lv.1] K번째수 - 복습
- ✅ [프로그래머스 Lv.1] 모의고사 - 복습 ⭐⭐

### 풀이한 문제 (Day 2)

- ✅ [프로그래머스 Lv.1] 같은 숫자는 싫어 ⭐⭐
- ✅ [프로그래머스 Lv.2] 기능개발 ⭐⭐⭐
- ✅ [프로그래머스 Lv.2] 올바른 괄호 ⭐⭐

### 새롭게 배운 것

#### 1. Day 1 복습의 중요성

**완주하지 못한 선수 복습:**

- Map을 다시 한번 복습하며 개념 확실히!
- `map.set(name, (map.get(name) || 0) + 1)` 패턴 숙달
- 빈도수 카운팅은 Map이 최적

**K번째수 복습:**

- `slice(i-1, j).sort((a,b) => a-b)[k-1]`
- 메서드 체이닝의 힘
- 1-based 인덱스를 0-based로 변환하는 패턴

**모의고사 복습:**

- 나머지 연산자(%)로 패턴 반복
- 각 패턴의 길이가 다를 때 주의
- `Math.max()`로 최댓값 찾기

#### 2. 스택의 활용 (같은 숫자는 싫어)

**연속된 숫자 제거:**

```typescript
const answer: number[] = [];
for (const num of arr) {
  if (answer.length === 0 || answer[answer.length - 1] !== num) {
    answer.push(num);
  }
}
```

**핵심 개념:**

- 바로 직전 원소와만 비교 (연속 체크)
- `answer[answer.length - 1]`: 마지막 원소 확인
- 스택의 LIFO 특성 활용

**filter를 사용한 다른 방법:**

```typescript
return arr.filter((num, index) => num !== arr[index + 1]);
```

- 현재 원소와 다음 원소 비교
- 마지막 원소는 항상 남음 (`undefined`와 비교)

#### 3. 큐와 그룹화 (기능개발) ⭐⭐⭐

**프로세스:**

1. 각 기능의 완료 일수 계산

   ```typescript
   const days = Math.ceil((100 - progress) / speed);
   ```

2. 첫 번째 기능은 무조건 배포
3. 다음 기능이 첫 번째보다 먼저/같이 완성 → 함께 배포
4. 늦게 완성 → 새로운 배포
5. 반복

**핵심 로직:**

```typescript
let count = 1;
let currentDay = days[0]; // 현재 배포일

for (let i = 1; i < days.length; i++) {
  if (days[i] <= currentDay) {
    count++; // 함께 배포
  } else {
    answer.push(count); // 그룹 마무리
    currentDay = days[i]; // 새로운 배포일
    count = 1; // 새 그룹 시작
  }
}
answer.push(count); // 마지막 그룹
```

**그룹화 패턴:**

- `currentDay`: 현재 그룹의 기준
- `count`: 현재 그룹의 크기
- 조건 변경 시 그룹 마무리

#### 4. 스택과 괄호 검증 (올바른 괄호)

**스택 방법:**

```typescript
const stack = [];
for (const char of s) {
  if (char === "(") {
    stack.push(char);
  } else {
    if (stack.length === 0) return false; // 조기 반환!
    stack.pop();
  }
}
return stack.length === 0;
```

**카운터 방법 (더 효율적!):**

```typescript
let count = 0;
for (const char of s) {
  if (char === "(") count++;
  else {
    count--;
    if (count < 0) return false;
  }
}
return count === 0;
```

**핵심:**

- 조기 반환으로 효율성 향상
- 스택 방법: O(n) 공간
- 카운터 방법: O(1) 공간

### 어려웠던 점

#### 1. 기능개발 문제 이해

- 처음엔 문제가 복잡하게 느껴짐
- "앞 기능이 배포되어야 뒤 기능도 배포 가능" 개념 이해 필요
- 단계별로 나눠서 생각하니 훨씬 쉬워짐

#### 2. 그룹화 로직

- `currentDay`와 `count` 개념 파악이 중요
- 반복문 시작 인덱스 (i=1부터!)
- 마지막 그룹 추가 (`answer.push(count)`)를 잊지 말아야 함

#### 3. 올바른 괄호 - 버그 수정

**처음 작성한 코드:**

```typescript
if (array[i] === ")") {
  const lastStack = stack[stack.length - 1];
  if (lastStack === "(") {
    // 이 체크가 문제!
    stack.pop();
  }
}
```

**문제점:**

- `)` 인데 스택이 비어있으면 `lastStack`이 `undefined`
- `undefined === "("` 는 false
- pop을 안 해서 잘못된 결과

**해결:**

```typescript
if (char === ")") {
  if (stack.length === 0) return false; // 즉시 반환!
  stack.pop();
}
```

### 느낀 점

#### 1. 복습의 효과

- Day 1 문제들을 다시 풀어보니 훨씬 빠르고 정확하게 풀림
- Map, Set, 정렬 개념이 확실히 자리 잡음
- 반복 학습의 중요성 재확인!

#### 2. Day 2 시작 - 스택/큐

- 스택과 큐는 생각보다 어렵지 않음
- 핵심은 **"언제 사용하는가?"**를 이해하는 것
- 스택: 최근 요소 관리 (LIFO)
- 큐: 순서대로 처리 (FIFO)

#### 3. 그룹화 패턴의 중요성

- 기능개발 문제에서 배운 그룹화 패턴
- 조건에 따라 요소들을 묶는 방법
- 다른 문제에도 자주 사용될 것 같음

#### 4. 문제 이해의 중요성

- 기능개발 문제는 처음에 복잡해 보였지만
- 한 단계씩 나눠서 생각하니 해결 가능
- "완료 일수 계산 → 그룹화" 단순한 2단계!

#### 5. 조기 반환(Early Return)

- 불가능한 경우를 빨리 발견하면 즉시 반환
- 효율성 향상
- 코드 가독성도 좋아짐

#### 6. 여러 풀이 방법 이해

- 같은 문제도 여러 방법으로 접근 가능
- 스택 vs 카운터
- filter vs for 반복문
- 각 방법의 장단점 이해가 중요

### 추가 학습 내용

#### Math.ceil() 활용

- 올림이 필요한 경우 사용
- 기능개발에서 일수 계산에 필수
- `Math.ceil(2.3)` → 3

#### for...of의 편리함

- 문자열도 바로 순회 가능
- `split("")` 불필요
- 코드가 더 간결해짐

---

## 📊 오늘의 통계

- **복습**: 3개 (Day 1 전체)
- **신규 문제**: 3개 (Day 2 스택/큐 파트 완료)
- **총 학습 시간**: 약 5시간
- **난이도**: Lv.1 ~ Lv.2
- **집중 주제**: 스택, 큐, 그룹화, 조기 반환

## 🎯 내일 계획

- Day 2 남은 부분 (문자열 처리)
- Day 3 시작 가능하면 진행
- 복습 시간도 확보

## 💡 주요 성취

- ✅ Day 1 전체 복습 완료
- ✅ Day 2 스택/큐 파트 완료
- ✅ 그룹화 패턴 학습
- ✅ 조기 반환 패턴 이해
- ✅ 복습의 효과 체감
- ✅ Lv.2 문제 2개 해결!

## 📝 기억할 점

1. **연속 vs 중복**

   - 연속: 바로 직전과만 비교
   - 중복: 전체에서 같은 값 확인

2. **그룹화 패턴**

   - 기준값 설정 (`currentDay`)
   - 카운터 관리 (`count`)
   - 조건 변경 시 그룹 마무리

3. **조기 반환**

   - 불가능한 경우 즉시 false
   - 불필요한 연산 줄이기

4. **for 반복문 시작 인덱스 주의**
   - 첫 번째를 기준으로 하면 `i=1`부터!

## 🔥 연속 학습

- 연속 학습일: **5일** 🔥🔥🔥🔥🔥
- 목표: 다음주 화요일 코딩테스트까지 매일 5시간!

