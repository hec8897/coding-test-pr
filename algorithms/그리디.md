# 그리디 알고리즘 (Greedy Algorithm)

> **"매 순간 최선의 선택을 하면, 전체적으로도 최선의 결과를 얻을 수 있다"**

학습 날짜: 2025-10-31

---

## 🎯 핵심 개념

그리디 알고리즘은 **현재 상황에서 가장 좋은 것을 선택**하는 방식입니다.
미래를 생각하지 않고, 지금 당장 최선의 선택을 반복하여 최적해를 찾습니다.

### 특징
- ✅ **직관적**: 사람이 자연스럽게 생각하는 방식
- ✅ **빠름**: 대부분 O(n log n) 시간 복잡도
- ✅ **정렬 활용**: 대부분의 문제에서 정렬부터 시작
- ⚠️ **주의**: 모든 문제에 적용 가능한 것은 아님 (최적해를 보장하는지 확인 필요)

---

## 🍕 실생활 예시

### 예시 1: 거스름돈 (동전 개수 최소화)

**문제**: 거스름돈 1,260원을 최소 동전 개수로 주기

**동전**: 500원, 100원, 50원, 10원

**그리디 방식**:
```
1단계: 가장 큰 동전부터! 
   → 500원 × 2개 = 1,000원 (남은 돈: 260원)

2단계: 다음으로 큰 동전
   → 100원 × 2개 = 200원 (남은 돈: 60원)

3단계: 다음으로 큰 동전
   → 50원 × 1개 = 50원 (남은 돈: 10원)

4단계: 마지막 동전
   → 10원 × 1개 = 10원 (남은 돈: 0원)

결과: 총 6개의 동전 ✨ (최소!)
```

**왜 이게 최적일까?**
- 큰 동전을 많이 사용할수록 전체 동전 개수가 줄어듦
- 작은 동전부터 사용하면 개수가 많아짐

### 예시 2: 회의실 배정

**문제**: 회의실 1개에 최대한 많은 회의를 배정하기

**회의 목록**:
- A: 9시~12시 (3시간)
- B: 10시~11시 (1시간)
- C: 11시~13시 (2시간)
- D: 13시~14시 (1시간)

**그리디 방식**:
```
1. 빨리 끝나는 회의부터 선택!
   (끝나는 시간 기준으로 정렬)

2. B 선택 (11시 끝) ✅
   → 11시 이후 회의 가능

3. D 선택 (14시 끝) ✅
   → 11시~13시에 시작하는 C는 불가능

결과: 총 2개의 회의 배정 ✨
```

**만약 A를 먼저 선택했다면?**
- A 선택 (12시 끝) → 나머지 회의 모두 불가능
- 결과: 1개만 배정 (손해! ❌)

---

## 🔑 그리디가 성립하는 조건

### 1️⃣ 최적 부분 구조 (Optimal Substructure)
- 전체 문제의 최적해 = 부분 문제의 최적해들의 조합
- 작은 선택들이 모여서 전체 최적해를 만듦

### 2️⃣ 탐욕 선택 속성 (Greedy Choice Property)
- 매 순간의 최선의 선택이 전체 최적해를 해치지 않음
- "지금 당장 가장 좋은 것"을 선택해도 괜찮음

---

## 💭 그리디 vs DFS 비교

| 구분 | 그리디 (Greedy) | DFS (깊이 우선 탐색) |
|------|----------------|---------------------|
| **사고방식** | 지금 당장 최선 선택 | 모든 경우의 수 탐색 |
| **속도** | ⚡ 빠름 O(n log n) | 🐌 느림 O(2ⁿ) |
| **난이도** | 😊 쉬움 (직관적) | 😵 어려움 (재귀 복잡) |
| **정렬 활용** | ✅ 자주 사용 | ❌ 거의 안 씀 |
| **적용 범위** | 제한적 (조건 필요) | 넓음 (모든 경우) |
| **예시** | 거스름돈, 구명보트, 회의실 배정 | 타겟 넘버, 모음 사전 |

**→ 그리디가 훨씬 쉽고 직관적! 먼저 그리디로 접근해보고, 안 되면 다른 방법 고려** 😊

---

## 🛠️ 그리디 문제 푸는 3단계

### Step 1: 정렬하기 📊
대부분의 그리디 문제는 **정렬**에서 시작!

```typescript
// 오름차순 정렬 (작은 것부터)
arr.sort((a, b) => a - b);

// 내림차순 정렬 (큰 것부터)
arr.sort((a, b) => b - a);

// 객체 정렬 (특정 속성 기준)
meetings.sort((a, b) => a.endTime - b.endTime);
```

### Step 2: 탐욕적 선택 기준 정하기 🎯
**"무엇을 먼저 선택할 것인가?"**
- 가장 큰 것? 가장 작은 것?
- 가장 빨리 끝나는 것?
- 가장 효율적인 것?

### Step 3: 선택하고 다음으로 이동 ➡️
- 선택한 것은 다시 고려하지 않음
- 한 방향으로만 진행
- 뒤돌아보지 않음!

---

## 🎯 그리디 문제 패턴

### 패턴 1: 정렬 + 양쪽 포인터 (Two Pointers)

**특징**: 배열의 양쪽 끝에서 시작하여 조건에 따라 선택

```typescript
// 1. 정렬
arr.sort((a, b) => a - b);

// 2. 양쪽 포인터 초기화
let left = 0;                    // 가장 작은 값
let right = arr.length - 1;      // 가장 큰 값

// 3. 양쪽에서 좁혀가며 선택
while (left < right) {
  if (arr[left] + arr[right] <= 조건) {
    // 둘 다 선택
    left++;
    right--;
  } else {
    // 한쪽만 선택
    right--;
  }
  count++;
}
```

**적용 문제**:
- 🚤 구명보트
- 🔢 두 수의 합
- 💧 물병

---

### 패턴 2: 정렬 + 순회

**특징**: 정렬 후 순서대로 탐욕적 선택

```typescript
// 1. 정렬 (문제에 따라 오름차순/내림차순)
arr.sort((a, b) => a - b);

// 2. 순회하며 선택
for (let i = 0; i < arr.length; i++) {
  if (조건 만족) {
    // 선택하기
    선택++;
  }
}
```

**적용 문제**:
- 👕 체육복
- 📅 회의실 배정
- 🍪 쿠키 나눠주기

---

### 패턴 3: 정렬 + 스택

**특징**: 스택을 사용하여 최적의 선택 유지

```typescript
// 1. 정렬 (보통 내림차순)
arr.sort((a, b) => b - a);

// 2. 스택으로 관리
const stack = [];

for (let item of arr) {
  // 스택 top과 비교하며 선택
  while (stack.length > 0 && 조건) {
    stack.pop();  // 더 좋은 선택을 위해 제거
  }
  stack.push(item);
}
```

**적용 문제**:
- 🔢 큰 수 만들기
- 📈 주식 가격
- 🏔️ 봉우리

---

## 📚 그리디 학습 로드맵

### Level 1: 기초 (정렬 + 순회)
- [ ] 체육복
- [ ] 큰 수 만들기 (입문)

### Level 2: 중급 (투 포인터)
- [ ] 구명보트 ⭐
- [ ] 단속카메라

### Level 3: 고급 (복잡한 조건)
- [ ] 섬 연결하기
- [ ] 저울

---

## 💡 문제 풀이 팁

### ✅ 그리디를 의심해봐야 할 때
- "최소" 또는 "최대"를 구하라
- 정렬하면 패턴이 보일 것 같다
- 직관적으로 "이렇게 하면 되겠다" 싶을 때

### ❌ 그리디가 안 될 때
- 반례를 찾았을 때
- 이전 선택이 이후에 영향을 줄 때
- 여러 경우를 고려해야 할 때
→ DP, DFS/BFS 고려

### 🧪 검증 방법
1. 간단한 예제로 테스트
2. 극단적인 경우 생각해보기
   - 모두 같은 값?
   - 최솟값/최댓값만?
3. 반례가 있는지 찾아보기

---

## 🎓 핵심 요약

1. **정렬부터 하기** - 대부분의 그리디 문제는 정렬이 첫 단계
2. **탐욕적 기준 정하기** - "무엇을 먼저 선택할까?" 명확히 하기
3. **뒤돌아보지 않기** - 한 번 선택하면 다시 고려하지 않음
4. **직관을 믿기** - "이렇게 하면 되겠다" 싶으면 시도해보기
5. **반례 찾기** - 항상 반례가 있는지 확인

---

## 🔗 관련 개념

- **정렬 (Sorting)**: 그리디의 기본! 꼭 숙지
- **투 포인터 (Two Pointers)**: 그리디와 자주 함께 사용
- **스택/큐**: 그리디 + 자료구조 조합
- **DP vs 그리디**: 그리디가 안 되면 DP 고려

---

## 📝 연습 문제

### 프로그래머스
- [Lv.1] 체육복
- [Lv.2] 구명보트 ⭐
- [Lv.2] 큰 수 만들기
- [Lv.2] 조이스틱
- [Lv.3] 섬 연결하기

### 백준
- 11047번: 동전 0
- 1931번: 회의실 배정
- 2839번: 설탕 배달

---

**마지막 업데이트**: 2025-10-31  
**다음 학습 예정**: 구현, DP, 이진탐색

