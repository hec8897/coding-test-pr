# 재귀 (Recursion)

> **"함수가 자기 자신을 호출하는 것"**

학습 날짜: 2025-10-31

---

## 🎯 핵심 개념

재귀는 **함수가 자기 자신을 호출**하여 문제를 해결하는 방식입니다.
큰 문제를 작은 문제로 나누고, 작은 문제를 같은 방식으로 해결합니다.

### 특징
- ✅ **간결함**: 복잡한 문제를 단순하게 표현
- ✅ **반복 대체**: for/while 대신 사용 가능
- ⚠️ **이해 어려움**: 머릿속으로 흐름 파악이 어려움
- ⚠️ **스택 오버플로우**: 너무 깊은 재귀는 위험

---

## 🍕 실생활 예시

### 예시 1: 러시안 인형 (마트료시카)

**문제**: 가장 작은 인형 찾기

```
큰 인형을 열면
  → 중간 인형이 나옴
    중간 인형을 열면
      → 작은 인형이 나옴
        작은 인형을 열면
          → 더 이상 없음 (종료!)
```

**재귀로 표현**:
```typescript
function 인형열기(인형) {
  if (인형 == null) {
    return "끝!";  // 종료 조건
  }
  return 인형열기(인형.안에있는인형);  // 자기 자신 호출
}
```

---

### 예시 2: 계단 내려가기

**문제**: 10층에서 1층까지 내려가기

```
10층에서 시작
  → 9층으로 내려감 (1층까지 가는 문제)
    → 8층으로 내려감 (1층까지 가는 문제)
      → 7층으로 내려감 (1층까지 가는 문제)
        ...
          → 1층 도착! (종료)
```

**재귀로 표현**:
```typescript
function 계단내려가기(층) {
  console.log(층 + "층");
  
  if (층 === 1) {
    console.log("도착!");  // 종료 조건
    return;
  }
  
  계단내려가기(층 - 1);  // 자기 자신 호출
}

계단내려가기(10);
// 10층 → 9층 → 8층 → ... → 1층 → 도착!
```

---

## 🔑 재귀의 2가지 필수 요소

### 1️⃣ 종료 조건 (Base Case)
**"언제 멈출 것인가?"**

```typescript
if (조건) {
  return 값;  // 여기서 멈춤!
}
```

**없으면?** → 무한 반복! 스택 오버플로우! 💥

### 2️⃣ 재귀 호출 (Recursive Case)
**"어떻게 작게 만들 것인가?"**

```typescript
return 함수(더_작은_문제);  // 자기 자신 호출
```

**목표**: 점점 작아져서 종료 조건에 도달!

---

## 📚 기본 예제: 팩토리얼

### 문제: n! = n × (n-1) × (n-2) × ... × 1

**반복문 (for)**:
```typescript
function factorial(n: number): number {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}

factorial(5);  // 5 × 4 × 3 × 2 × 1 = 120
```

**재귀 (Recursion)**:
```typescript
function factorial(n: number): number {
  // 1️⃣ 종료 조건
  if (n === 1) {
    return 1;
  }
  
  // 2️⃣ 재귀 호출
  return n * factorial(n - 1);
}

factorial(5);
// 5 * factorial(4)
//     4 * factorial(3)
//         3 * factorial(2)
//             2 * factorial(1)
//                 1  ← 종료!
//             2 * 1 = 2
//         3 * 2 = 6
//     4 * 6 = 24
// 5 * 24 = 120 ✨
```

---

## 🔍 재귀 실행 과정 (Call Stack)

### 예시: factorial(3)

```
1. factorial(3) 호출
   └─ 3 * factorial(2) 계산 필요
      
2. factorial(2) 호출
   └─ 2 * factorial(1) 계산 필요
      
3. factorial(1) 호출
   └─ 종료 조건! return 1
   
4. factorial(2)로 돌아감
   └─ 2 * 1 = 2 반환
   
5. factorial(3)으로 돌아감
   └─ 3 * 2 = 6 반환

결과: 6 ✨
```

**Call Stack 시각화**:
```
factorial(3)
  ↓ 호출
factorial(2)
  ↓ 호출
factorial(1)  ← 종료! return 1
  ↑ 반환 1
factorial(2)  ← 2 * 1 = 2
  ↑ 반환 2
factorial(3)  ← 3 * 2 = 6
```

---

## 🎯 재귀 문제 풀이 패턴

### 패턴 1: 단순 재귀 (선형)

**특징**: 한 번만 자기 자신을 호출

```typescript
function 단순재귀(n) {
  // 종료 조건
  if (n === 0) return 결과;
  
  // 재귀 호출
  return 단순재귀(n - 1);
}
```

**예시**: 팩토리얼, 피보나치, 숫자 세기

---

### 패턴 2: 분기 재귀 (트리)

**특징**: 여러 번 자기 자신을 호출

```typescript
function 분기재귀(n) {
  // 종료 조건
  if (n === 0) return 결과;
  
  // 여러 번 재귀 호출
  const case1 = 분기재귀(n - 1);
  const case2 = 분기재귀(n - 1);
  return case1 + case2;
}
```

**예시**: DFS, 타겟 넘버, 모음 사전

---

### 패턴 3: 백트래킹 (탐색 + 되돌리기)

**특징**: 탐색 후 상태를 되돌림

```typescript
function 백트래킹(상태) {
  // 종료 조건
  if (목표 달성) return;
  
  // 선택지들을 탐색
  for (let 선택 of 선택지들) {
    상태 변경;           // 선택
    백트래킹(새로운_상태);  // 재귀
    상태 복원;           // 되돌리기
  }
}
```

**예시**: 순열, 조합, N-Queen

---

## 💡 재귀를 반복문으로, 반복문을 재귀로

### 반복문 → 재귀

**반복문**:
```typescript
for (let i = 1; i <= 5; i++) {
  console.log(i);
}
```

**재귀**:
```typescript
function print(i: number, max: number) {
  if (i > max) return;  // 종료 조건
  console.log(i);
  print(i + 1, max);    // 재귀 호출
}

print(1, 5);
```

---

### 재귀 → 반복문

**재귀**:
```typescript
function sum(n: number): number {
  if (n === 0) return 0;
  return n + sum(n - 1);
}
```

**반복문**:
```typescript
function sum(n: number): number {
  let result = 0;
  for (let i = 1; i <= n; i++) {
    result += i;
  }
  return result;
}
```

---

## 🎓 코딩 테스트 자주 나오는 재귀 문제

### 1️⃣ DFS (깊이 우선 탐색)

```typescript
function dfs(index: number, sum: number): number {
  // 종료 조건: 끝까지 탐색했을 때
  if (index === numbers.length) {
    return sum === target ? 1 : 0;
  }
  
  // 재귀 호출: 더하기/빼기 두 가지 선택
  const plusWay = dfs(index + 1, sum + numbers[index]);
  const minusWay = dfs(index + 1, sum - numbers[index]);
  
  return plusWay + minusWay;
}
```

**대표 문제**: 타겟 넘버, 네트워크, 단어 변환

---

### 2️⃣ 분할 정복

```typescript
function 하노이(n: number, from: number, to: number, via: number) {
  // 종료 조건: 원반 1개
  if (n === 1) {
    console.log(`${from} → ${to}`);
    return;
  }
  
  // 재귀 호출: 3단계
  하노이(n - 1, from, via, to);      // 1. n-1개를 보조로
  console.log(`${from} → ${to}`);     // 2. 가장 큰 것을 목표로
  하노이(n - 1, via, to, from);      // 3. n-1개를 목표로
}
```

**대표 문제**: 하노이의 탑, 병합 정렬, 퀵 정렬

---

### 3️⃣ 조합/순열

```typescript
// 조합
function 조합(arr: number[], n: number, start: number, chosen: number[]) {
  // 종료 조건: n개 선택 완료
  if (chosen.length === n) {
    결과.push([...chosen]);
    return;
  }
  
  // 재귀 호출: 선택하거나 안 하거나
  for (let i = start; i < arr.length; i++) {
    chosen.push(arr[i]);           // 선택
    조합(arr, n, i + 1, chosen);    // 재귀
    chosen.pop();                  // 취소 (백트래킹)
  }
}
```

**대표 문제**: 모음 사전, 카펫, 소수 찾기

---

## ⚠️ 재귀 사용 시 주의사항

### 1️⃣ 종료 조건 필수!

**나쁜 예**:
```typescript
function bad(n) {
  return bad(n - 1);  // 종료 조건 없음! 💥
}
```

**좋은 예**:
```typescript
function good(n) {
  if (n === 0) return;  // 종료 조건 ✅
  return good(n - 1);
}
```

---

### 2️⃣ 스택 오버플로우 주의

```typescript
// n이 너무 크면?
factorial(10000);  // 스택 오버플로우! 💥
```

**해결책**:
- 반복문으로 대체
- 꼬리 재귀 최적화 (Tail Recursion)
- 메모이제이션 (DP)

---

### 3️⃣ 중복 계산 주의

**피보나치 (비효율적)**:
```typescript
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);  // 중복 계산 많음!
}

fib(5);
// fib(4) + fib(3)
//   fib(3) + fib(2)  ← fib(3) 중복!
```

**해결책**: 메모이제이션
```typescript
const memo = {};

function fib(n) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];  // 이미 계산했으면 재사용
  
  memo[n] = fib(n - 1) + fib(n - 2);
  return memo[n];
}
```

---

## 💭 재귀 vs 반복문

| 구분 | 재귀 | 반복문 |
|------|------|--------|
| **코드 길이** | 짧음 ✅ | 길 수 있음 |
| **가독성** | 문제에 따라 직관적 | 대부분 명확 |
| **성능** | 느림 (함수 호출 오버헤드) | 빠름 ✅ |
| **메모리** | 많음 (Call Stack) | 적음 ✅ |
| **스택 오버플로우** | 위험 있음 ⚠️ | 없음 ✅ |
| **적용 분야** | DFS, 분할정복, 트리 | 단순 반복, 최적화 필요 |

**결론**: 문제에 맞게 선택! 트리/그래프는 재귀, 단순 반복은 반복문

---

## 🎯 재귀 학습 로드맵

### Level 1: 기초 (단순 재귀)
- [ ] 팩토리얼
- [ ] 숫자 세기
- [ ] 배열 합 구하기

### Level 2: 중급 (분기 재귀)
- [ ] 피보나치
- [ ] 타겟 넘버 ⭐
- [ ] 모음 사전

### Level 3: 고급 (백트래킹)
- [ ] 순열/조합
- [ ] N-Queen
- [ ] 스도쿠

---

## 💡 재귀 디버깅 팁

### 1️⃣ console.log로 흐름 파악

```typescript
function factorial(n: number): number {
  console.log(`factorial(${n}) 호출`);
  
  if (n === 1) {
    console.log(`factorial(1) 종료: 1 반환`);
    return 1;
  }
  
  const result = n * factorial(n - 1);
  console.log(`factorial(${n}) 반환: ${result}`);
  return result;
}
```

---

### 2️⃣ 작은 예제로 시작

```typescript
// 큰 값으로 테스트하면 흐름 파악 어려움
factorial(10);  // ❌

// 작은 값으로 시작
factorial(3);   // ✅
```

---

### 3️⃣ 종료 조건 먼저 확인

```typescript
function dfs(index, sum) {
  // 먼저 종료 조건 체크!
  console.log(`index: ${index}, sum: ${sum}`);
  
  if (index === numbers.length) {
    console.log("종료!");
    return ...;
  }
  
  // 재귀 호출
  ...
}
```

---

## 🎓 핵심 요약

1. **재귀 = 자기 자신 호출** - 큰 문제를 작은 문제로
2. **종료 조건 필수** - 없으면 무한 반복
3. **Call Stack 이해** - 호출과 반환의 흐름
4. **패턴 익히기** - 단순, 분기, 백트래킹
5. **작은 예제로 연습** - 흐름 파악이 핵심

---

## 🔗 관련 개념

- **DFS (깊이 우선 탐색)**: 재귀의 대표적 활용
- **분할 정복**: 재귀로 문제를 나눔
- **백트래킹**: 재귀 + 상태 되돌리기
- **DP (동적 계획법)**: 재귀 + 메모이제이션

---

## 📝 연습 문제

### 프로그래머스
- [Lv.0] 팩토리얼
- [Lv.2] 타겟 넘버 ⭐
- [Lv.2] 모음 사전 (어려움)
- [Lv.2] 하노이의 탑

### 백준
- 10872번: 팩토리얼
- 2447번: 별 찍기 - 10
- 1914번: 하노이 탑

---

**마지막 업데이트**: 2025-10-31  
**다음 학습 예정**: 백트래킹, DP, 이진탐색

