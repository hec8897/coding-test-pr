# [Lv.2] 조이스틱

## 📌 문제 설명

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.

예를 들어, 이름이 "JAZ"라면 "AAA"에서 시작합니다.

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

- **▲ (위)**: 다음 알파벳 (A → B → C → ... → Z)
- **▼ (아래)**: 이전 알파벳 (Z → Y → X → ... → A)
- **◀ (왼쪽)**: 커서를 왼쪽으로 이동 (한 칸)
- **▶ (오른쪽)**: 커서를 오른쪽으로 이동 (한 칸)

예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.

```
- 첫 번째 위치에서, 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자에 이동시킵니다.
- 마지막 위치에서, 조이스틱을 위로 1번 조작하여 Z를 완성합니다.
따라서 11번의 조작으로 "JAZ"를 만들 수 있습니다.
```

만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

---

## 🔒 제한사항

- name은 알파벳 대문자로만 이루어져 있습니다.
- name의 길이는 1 이상 20 이하입니다.

---

## 📥 입출력 예

| name     | return |
| -------- | ------ |
| "JEROEN" | 56     |
| "JAN"    | 23     |

---

## 💡 핵심 아이디어

이 문제는 **2가지를 최적화**해야 합니다:

### 1️⃣ **상하 조작 (알파벳 변경)**

각 알파벳을 A에서 바꾸는 최소 조작 횟수:

```typescript
// A → B → C → ... (위로)
// A → Z → Y → ... (아래로)

예: A → N
- 위로: A→B→C→D→E→F→G→H→I→J→K→L→M→N (13번)
- 아래로: A→Z→Y→X→W→V→O→N (7번)
→ 최소: 7번 ✨

예: A → B
- 위로: A→B (1번)
- 아래로: A→Z→Y→...→B (25번)
→ 최소: 1번 ✨
```

**공식**:

```typescript
const up = target.charCodeAt(0) - "A".charCodeAt(0); // 위로 가는 횟수
const down = "Z".charCodeAt(0) - target.charCodeAt(0) + 1; // 아래로 가는 횟수
const min = Math.min(up, down);
```

---

### 2️⃣ **좌우 조작 (커서 이동)** ⭐⭐⭐

**이 부분이 핵심이자 어려운 부분!**

순서대로 오른쪽으로만 가면?

```
"JAZ" (3글자)
J → A → Z
커서 이동: 2번 (오른쪽 2번)
```

하지만 A는 이미 완성되어 있음!

```
"JAZ"
 ↓   ↓
 변경 필요 (A는 변경 불필요!)

더 빠른 방법:
J 완성 → 왼쪽으로 가서 Z 완성!
커서 이동: 1번 (왼쪽 1번) ✨
```

---

### 🎯 커서 이동 최적화 전략

3가지 경우를 비교해야 합니다:

#### 경우 1: **순서대로 오른쪽으로만**

```
0 → 1 → 2 → 3 → ... → n-1
이동 횟수: n-1
```

#### 경우 2: **오른쪽 갔다가 되돌아와서 왼쪽**

```
예: "BBBAAAAAB"
     012345678

B를 만나면 돌아가기:
0 → 1 → 2 (B 3개 완성)
2 → 1 → 0 → 8 (왼쪽 끝으로)

이동 횟수: 2 + 2 + 1 = 5
(오른쪽 2번 + 되돌아오기 2번 + 왼쪽 1번)
```

#### 경우 3: **왼쪽 갔다가 되돌아와서 오른쪽**

```
예: "BAAAAAAAB"
     012345678

왼쪽부터:
0 → 8 (왼쪽 끝 B 완성)
8 → 0 → 1 (오른쪽 B 완성)

이동 횟수: 1 + 1 + 1 = 3
(왼쪽 1번 + 되돌아오기 1번 + 오른쪽 1번)
```

---

## 🔑 알고리즘 흐름

### Step 1: 상하 조작 계산 (간단)

```typescript
let moves = 0;
for (let i = 0; i < name.length; i++) {
  const char = name[i];
  if (char !== "A") {
    const up = char.charCodeAt(0) - "A".charCodeAt(0);
    const down = "Z".charCodeAt(0) - char.charCodeAt(0) + 1;
    moves += Math.min(up, down);
  }
}
```

---

### Step 2: 좌우 조작 계산 (복잡)

```typescript
let minMove = name.length - 1; // 기본: 순서대로 오른쪽

for (let i = 0; i < name.length; i++) {
  let next = i + 1;

  // A가 연속으로 나오는 구간 찾기
  while (next < name.length && name[next] === "A") {
    next++;
  }

  // 오른쪽 갔다가 왼쪽: i * 2 + (name.length - next)
  const rightLeft = i * 2 + (name.length - next);

  // 왼쪽 갔다가 오른쪽: (name.length - next) * 2 + i
  const leftRight = (name.length - next) * 2 + i;

  minMove = Math.min(minMove, rightLeft, leftRight);
}
```

---

## 🎓 핵심 개념

- ⭐⭐⭐ **그리디 알고리즘** (Greedy)
- ⭐⭐ **최적화** (Optimization)
- ⭐ **문자열 처리**

---

## 💭 왜 그리디인가?

1. **상하 조작**: 각 알파벳마다 최소 조작 선택 (위 vs 아래)
2. **좌우 조작**: 각 연속 A 구간마다 최소 이동 선택 (직진 vs 되돌아가기)

---

## ⚠️ 주의사항

### 1. A는 변경할 필요 없음!

```typescript
if (name[i] === "A") continue; // 건너뛰기
```

### 2. 연속된 A 구간을 찾아야 함

```typescript
while (next < name.length && name[next] === "A") {
  next++;
}
```

### 3. 3가지 경우를 모두 비교

```typescript
Math.min(순서대로, 오른쪽우선, 왼쪽우선);
```

---

## 📝 예시 상세 추적

### 예제: "JAZ"

#### Step 1: 상하 조작

```
J: A → J
   위로 9번 vs 아래로 17번
   → 9번 ✨

A: 변경 불필요 → 0번

Z: A → Z
   위로 25번 vs 아래로 1번
   → 1번 ✨

총 상하: 9 + 0 + 1 = 10번
```

#### Step 2: 좌우 조작

```
인덱스: 0(J) 1(A) 2(Z)

경우 1: 순서대로 오른쪽
  0 → 1 → 2
  이동: 2번

경우 2: 오른쪽 갔다가 왼쪽
  i=0: next=1 (A 시작)
  A 구간: 1~1
  오른쪽우선: 0 * 2 + (3 - 2) = 1
  왼쪽우선: (3 - 2) * 2 + 0 = 2

최소: 1번 ✨

총 좌우: 1번
```

#### 최종 답

```
상하(10) + 좌우(1) = 11번
```

---

## 🚀 같이 풀어봅시다!

이 문제는 **그리디의 고급 버전**입니다.

**Tip**:

- 상하는 쉬움! 각 알파벳마다 최소 선택
- 좌우가 어려움! 연속 A 구간을 잘 처리해야 함
- 3가지 경우를 꼭 비교하세요!

힌트를 보지 말고 먼저 시도해보세요! 😊
