# 옹알이 (1)

## 문제 정보

- **플랫폼**: 프로그래머스
- **레벨/난이도**: Lv.1
- **문제 링크**: [옹알이 (1)](https://school.programmers.co.kr/learn/courses/30/lessons/120956)
- **풀이 날짜**: 2025-10-25
- **재풀이**: ❌ (복습 예정)

## 문제 설명

머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 조카는 아직 **"aya", "ye", "woo", "ma"** 네 가지 발음을 **최대 한 번씩** 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다.

문자열 배열 `babbling`이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요.

### 제한사항

- 1 ≤ babbling의 길이 ≤ 100
- 1 ≤ babbling[i]의 길이 ≤ 15
- babbling의 각 문자열에서 "aya", "ye", "woo", "ma"는 각각 최대 한 번씩만 등장합니다.
- 문자열은 알파벳 소문자로만 이루어져 있습니다.

### 입출력 예

| babbling                                      | result |
| --------------------------------------------- | ------ |
| `["aya", "yee", "u", "maa", "wyeoo"]`         | 1      |
| `["ayaye", "uuuma", "ye", "yemawoo", "ayaa"]` | 3      |

### 입출력 예 설명

**예제 #1**

- `"aya"` → ✅ 발음 가능 ("aya")
- `"yee"` → ❌ 발음 불가 ("ye" + "e" 남음)
- `"u"` → ❌ 발음 불가 (조합 불가)
- `"maa"` → ❌ 발음 불가 ("ma" + "a" 남음)
- `"wyeoo"` → ❌ 발음 불가

결과: **1개**

**예제 #2**

- `"ayaye"` → ✅ 발음 가능 ("aya" + "ye")
- `"uuuma"` → ❌ 발음 불가 ("uu" 조합 불가)
- `"ye"` → ✅ 발음 가능 ("ye")
- `"yemawoo"` → ✅ 발음 가능 ("ye" + "ma" + "woo")
- `"ayaa"` → ❌ 발음 불가 ("aya" + "a" 남음)

결과: **3개**

## 접근 방법

### ❌ 잘못된 접근 (처음 시도)

1. 발음 가능한 조각(`"aya"`, `"ye"`, `"woo"`, `"ma"`)을 하나씩 제거
2. 모두 제거 후 빈 문자열이면 발음 가능하다고 판단

**문제점:**

```typescript
"wyeoo"
→ "ye" 제거 → "woo" (중간 문자 제거로 새 조합 생성!)
→ "woo" 제거 → "" (잘못된 판단!)
```

### ✅ 올바른 접근

1. **정규표현식**을 사용하여 문자열 전체가 발음 조각들로만 구성되었는지 **패턴 매칭**
2. 문자열이 처음부터 끝까지 발음 조각들의 연속된 조합인지 확인

**핵심:** 문자열 변환이 아닌 **문자열 검증**!

## 시간복잡도

- **시간**: O(n × m) - n은 babbling 배열 길이, m은 각 문자열 길이
- **공간**: O(1) - 상수 공간

## 풀이 코드

```typescript
function solution(babbling: string[]): number {
  let count = 0;

  // 정규표현식: 문자열이 처음부터 끝까지 발음 조각들로만 구성되어 있는지 확인
  // ^ : 문자열 시작
  // (aya|ye|woo|ma) : 이 4가지 중 하나
  // + : 1번 이상 반복
  // $ : 문자열 끝
  const regex = /^(aya|ye|woo|ma)+$/;

  for (let word of babbling) {
    if (regex.test(word)) {
      count++;
    }
  }

  return count;
}
```

## 핵심 개념: 정규표현식

### 기본 문법

```typescript
/^(aya|ye|woo|ma)+$/

^ - 문자열의 시작
$ - 문자열의 끝
| - OR (또는)
+ - 1번 이상 반복
* - 0번 이상 반복
() - 그룹화
```

### 예제로 이해하기

```typescript
const regex = /^(dog|cat)+$/;

regex.test("dog"); // true - "dog" 1번
regex.test("dogcat"); // true - "dog" + "cat"
regex.test("catdog"); // true - "cat" + "dog"
regex.test("dogbird"); // false - "bird"는 패턴에 없음
regex.test("do"); // false - 불완전한 조각
```

### 다른 유용한 정규표현식

```typescript
// 숫자만
/^\d+$/

// 알파벳만
/^[a-zA-Z]+$/

// 이메일
/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/

// 전화번호
/^01[0-9]-\d{3,4}-\d{4}$/
```

## 배운 점 / 느낀 점

### 1. 문제 이해가 가장 중요!

**처음 이해:** "발음 조각들을 찾아서 제거하면 되겠지?"  
**올바른 이해:** "문자열 **전체**가 발음 조각들**만**으로 구성되어야 함"

문제를 정확히 파악하지 못하면 아무리 코드를 잘 짜도 틀릴 수 있다!

### 2. `.replace()`의 함정

중간 문자를 제거하면 **원래 없던 새로운 조합**이 만들어질 수 있음:

```typescript
"wyeoo".replace("ye", ""); // "woo" (새로운 조합 생성!)
```

### 3. 정규표현식의 강력함

문자열 패턴 매칭에는 정규표현식이 최고!

- 간결한 코드
- 명확한 의도
- 실무에서도 자주 사용

### 4. 문제 풀이 프로세스

1. ✅ **문제 정확히 읽기** (가장 중요!)
2. 예제를 손으로 직접 풀어보기
3. 예외 케이스 생각하기
4. 코드 작성
5. 테스트 & 디버깅

### 5. 실무 연결

정규표현식은 실무에서 정말 많이 사용:

- 폼 입력 검증 (이메일, 전화번호, 비밀번호)
- 데이터 파싱
- 문자열 치환 및 검색

## 관련 개념

- **정규표현식 (Regular Expression)** ⭐⭐⭐
- 문자열 패턴 매칭
- `.test()` 메서드
- 문자열 검증 vs 문자열 변환의 차이
