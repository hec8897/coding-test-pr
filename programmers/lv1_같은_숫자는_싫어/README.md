# 같은 숫자는 싫어

## 📌 문제 설명

배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다.

예를 들면,

- arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
- arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.

배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.

## 제한사항

- 배열 arr의 크기 : 1,000,000 이하의 자연수
- 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수

## 입출력 예

| arr             | answer    |
| --------------- | --------- |
| [1,1,3,3,0,1,1] | [1,3,0,1] |
| [4,4,4,3,3]     | [4,3]     |

## 입출력 예 설명

**입출력 예 #1,2**

- 문제의 예시와 같습니다.

## 💡 풀이 방법

### 1. 스택을 사용한 방법

```typescript
function solution(arr: number[]): number[] {
  const stack: number[] = [];

  for (const num of arr) {
    // 스택이 비어있거나, 스택의 마지막 원소와 다르면 추가
    if (stack.length === 0 || stack[stack.length - 1] !== num) {
      stack.push(num);
    }
  }

  return stack;
}
```

### 2. filter를 사용한 방법

```typescript
function solution(arr: number[]): number[] {
  return arr.filter((num, index) => num !== arr[index + 1]);
}
```

## 🔍 주요 개념 설명

### 1. 스택(Stack)이란?

- **LIFO** (Last In First Out): 마지막에 들어간 것이 먼저 나옴
- 주요 메서드:
  - `push()`: 끝에 추가
  - `pop()`: 끝에서 제거
  - `stack[stack.length - 1]`: 마지막 원소 확인 (peek)

### 2. 이 문제에서 스택을 사용하는 이유

```typescript
// 예: [1, 1, 3, 3, 0, 1, 1]
stack = [];

// 1을 만남 → stack이 비어있으므로 추가 → [1]
// 1을 만남 → stack의 마지막(1)과 같으므로 추가하지 않음 → [1]
// 3을 만남 → stack의 마지막(1)과 다르므로 추가 → [1, 3]
// 3을 만남 → stack의 마지막(3)과 같으므로 추가하지 않음 → [1, 3]
// 0을 만남 → stack의 마지막(3)과 다르므로 추가 → [1, 3, 0]
// 1을 만남 → stack의 마지막(0)과 다르므로 추가 → [1, 3, 0, 1]
// 1을 만남 → stack의 마지막(1)과 같으므로 추가하지 않음 → [1, 3, 0, 1]
```

### 3. filter 방법의 동작 원리

```typescript
arr.filter((num, index) => num !== arr[index + 1]);

// 각 원소를 다음 원소와 비교
// 다음 원소와 다르면 남김
// 마지막 원소는 arr[index + 1]이 undefined이므로 항상 남음

// 예: [1, 1, 3, 3, 0, 1, 1]
// index 0: 1 !== 1 (다음) → false → 제거
// index 1: 1 !== 3 (다음) → true → 남김 [1]
// index 2: 3 !== 3 (다음) → false → 제거
// index 3: 3 !== 0 (다음) → true → 남김 [1, 3]
// index 4: 0 !== 1 (다음) → true → 남김 [1, 3, 0]
// index 5: 1 !== 1 (다음) → false → 제거
// index 6: 1 !== undefined → true → 남김 [1, 3, 0, 1]
```

## ⚠️ 주의사항

1. **연속된 숫자만 제거**

   - [1, 3, 1]은 [1, 3, 1]로 유지됨 (연속되지 않음)
   - [1, 1, 1]은 [1]이 됨 (연속됨)

2. **순서 유지**

   - 원래 배열의 순서를 그대로 유지해야 함

3. **마지막 원소 접근**
   ```typescript
   stack[stack.length - 1]; // 마지막 원소
   stack.at(-1); // 최신 문법 (동일한 기능)
   ```

## 💡 배운 점

1. **스택 자료구조의 활용**

   - 마지막 원소와의 비교가 필요한 경우
   - LIFO 구조의 특성 이해

2. **filter의 활용**

   - 조건에 맞는 원소만 남기기
   - index 파라미터 활용

3. **문제 해결 접근법**
   - 같은 문제를 여러 방법으로 해결
   - 각 방법의 장단점 이해

## 🚀 성능 비교

### 스택 방법

- 시간복잡도: O(n)
- 공간복잡도: O(n)
- 직관적이고 명확한 로직

### filter 방법

- 시간복잡도: O(n)
- 공간복잡도: O(n)
- 코드가 매우 간결함
- 함수형 프로그래밍 스타일

## ⭐️ 실전 팁

- 이 문제는 filter 방법이 더 간결하지만
- 스택 개념을 이해하는 것이 중요 (다른 문제에서도 자주 사용)
- 면접에서는 두 가지 방법을 모두 설명할 수 있으면 좋음
