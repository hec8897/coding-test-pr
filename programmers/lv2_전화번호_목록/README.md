# 전화번호 목록

**출처**: 프로그래머스 Lv.2  
**분류**: 해시  
**난이도**: ⭐⭐

## 📋 문제 설명

전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.

전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두어입니다.

- 구조대 : 119
- 박준영 : 97 674 223
- 지영석 : 11 9552 4421

전화번호부에 적힌 전화번호를 담은 배열 `phone_book`이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 `false`를, 그렇지 않으면 `true`를 return 하도록 solution 함수를 작성해주세요.

---

## 🚫 제한사항

- `phone_book`의 길이는 1 이상 1,000,000 이하입니다.
- 각 전화번호의 길이는 1 이상 20 이하입니다.
- 같은 전화번호가 중복해서 들어있지 않습니다.

---

## 📥 입출력 예

| phone_book                        | return |
| --------------------------------- | ------ |
| ["119", "97674223", "1195524421"] | false  |
| ["123","456","789"]               | true   |
| ["12","123","1235","567","88"]    | false  |

---

## 📥 입출력 예 설명

### 예제 #1
- 앞에서 설명한 예와 같습니다.
- "119"가 "1195524421"의 접두어이므로 `false`

### 예제 #2
- 어떤 번호도 다른 번호의 접두어가 아니므로 `true`

### 예제 #3
- "12"가 "123"의 접두어이므로 `false`

---

## 💡 풀이 접근

### 방법 1: 해시(Set) 활용 ⭐ 추천

**핵심 아이디어**:
1. 모든 전화번호를 Set에 저장
2. 각 전화번호의 부분 문자열이 Set에 있는지 확인

```typescript
// 예: "1195524421"의 부분 문자열들
"1", "11", "119", "1195", "11955", ...

// "119"가 Set에 있으면 → 접두어 발견!
```

**시간 복잡도**: O(n × m) (n: 전화번호 개수, m: 전화번호 평균 길이)

### 방법 2: 정렬 활용

**핵심 아이디어**:
1. 전화번호를 정렬
2. 정렬하면 접두어 관계는 인접한 번호끼리만 나타남
3. 인접한 것들만 비교

```typescript
// 정렬 전: ["119", "1195524421", "97674223"]
// 정렬 후: ["119", "1195524421", "97674223"]
//           ↑        ↑
//         바로 옆만 확인하면 됨!
```

**시간 복잡도**: O(n log n)

---

## 🎯 사용할 수 있는 메서드

### Set 관련
```typescript
const set = new Set(array);  // Set 생성
set.has(value);              // 값이 있는지 확인 (O(1))
```

### 문자열 관련
```typescript
string.substring(start, end);  // 부분 문자열
string.startsWith(prefix);     // 접두어 확인
```

### 정렬
```typescript
array.sort();  // 사전순 정렬
```

---

## 🔍 테스트 케이스

```typescript
// 기본 케이스
solution(["119", "97674223", "1195524421"]) // false

// 접두어 없는 경우
solution(["123","456","789"]) // true

// 짧은 접두어
solution(["12","123","1235","567","88"]) // false

// 엣지 케이스
solution(["1"]) // true (번호 1개)
solution(["123", "456"]) // true (완전히 다른 번호)
```

---

## 💭 생각해볼 점

1. **이중 for문이 필요한가?**
   - 해시 방법: 각 번호마다 부분 문자열 확인 → O(n × m)
   - 정렬 방법: 정렬 + 한 번 순회 → O(n log n)

2. **효율성은?**
   - 전화번호가 짧으면: 두 방법 비슷
   - 전화번호가 길면: 정렬이 더 효율적

3. **가독성은?**
   - 해시 방법: 직관적, 해시 개념 명확
   - 정렬 방법: 간결, 아이디어가 핵심

---

## 📚 참고

- **접두어(prefix)**: 문자열의 앞부분
  - "119"는 "1195524421"의 접두어
  - "97"은 "97674223"의 접두어

---

## 시간/공간 복잡도

### 해시 방법
- **시간**: O(n × m)
- **공간**: O(n)

### 정렬 방법
- **시간**: O(n log n + n × m)
- **공간**: O(1) (정렬만 사용)

---

## ✅ 체크리스트

- [ ] 모든 테스트 케이스 통과
- [ ] 효율성 테스트 통과
- [ ] 엣지 케이스 처리 (번호 1개, 완전히 다른 번호들)
- [ ] 시간 복잡도 확인

---

**💡 TIP**: 해시 문제니까 Set을 활용해보세요! 부분 문자열을 만들어서 Set에 있는지 확인하는 패턴을 익히면 좋습니다.

