# 모의고사

## 📌 문제 설명
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에서 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

## 💡 풀이 방법

### 1. 패턴 저장
```typescript
const patterns = [
    [1, 2, 3, 4, 5],            // 수포자1: 5개
    [2, 1, 2, 3, 2, 4, 2, 5],   // 수포자2: 8개
    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]  // 수포자3: 10개
];
```

### 2. 정답 체크
```typescript
// i번째 문제의 답을 체크할 때
patterns[0][i % 5]   // 수포자1의 답
patterns[1][i % 8]   // 수포자2의 답
patterns[2][i % 10]  // 수포자3의 답
```

### 3. 최종 코드
```typescript
function solution(answers: number[]): number[] {
    const patterns = [
        [1, 2, 3, 4, 5],
        [2, 1, 2, 3, 2, 4, 2, 5],
        [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    ];
    
    let std1 = 0, std2 = 0, std3 = 0;

    // 각 문제별로 정답 체크
    for (let i = 0; i < answers.length; i++) {
        if (patterns[0][i % 5] === answers[i]) std1 += 1;
        if (patterns[1][i % 8] === answers[i]) std2 += 1;
        if (patterns[2][i % 10] === answers[i]) std3 += 1;
    }

    // 최고점수 찾고 해당하는 수포자 반환
    const max = Math.max(std1, std2, std3);
    const result = [];
    if (std1 === max) result.push(1);
    if (std2 === max) result.push(2);
    if (std3 === max) result.push(3);
    
    return result;
}
```

## 🔍 주요 개념 설명

### 1. 나머지 연산자(%)
```typescript
i % 5  // 패턴의 길이로 나눈 나머지

// 예: i가 7일 때
7 % 5 = 2  // 다시 패턴의 처음으로 돌아감
```

### 2. Math.max()
```typescript
Math.max(1, 5, 3)  // 5 반환
Math.max(std1, std2, std3)  // 가장 높은 점수 찾기
```

### 3. 배열 메서드
```typescript
result.push(1)  // 배열에 값 추가
// result가 비어있다면 → [1]
// result가 [1]이라면 → [1, 2]
```

## ⚠️ 주의사항

1. **패턴 길이**
   - 각 수포자마다 패턴 길이가 다름
   - 나머지 연산 시 각각의 길이로 나눠야 함

2. **점수 계산**
   ```typescript
   std1 = +1   // ❌ 잘못된 방법 (항상 1이 됨)
   std1 += 1   // ✅ 올바른 방법 (1씩 증가)
   ```

3. **동점자 처리**
   - 최고점수와 같은 점수를 받은 모든 수포자를 배열에 추가
   - 자동으로 오름차순 정렬됨 (1, 2, 3 순서로 체크하므로)

## 💡 배운 점

1. **패턴 반복**
   - 나머지 연산자를 활용한 패턴 순환
   - 긴 입력도 짧은 패턴으로 처리 가능

2. **최댓값과 동점자**
   - Math.max()로 최댓값 찾기
   - 여러 최댓값 처리 방법

3. **코드 가독성**
   - 패턴을 배열로 명확하게 표현
   - 단계별로 로직 분리

## 🚀 개선 가능한 부분

1. **타입 안정성**
```typescript
interface Student {
    pattern: number[];
    score: number;
    id: number;
}
```

2. **확장성**
```typescript
// 수포자가 추가되어도 patterns에만 추가하면 됨
const patterns = [
    [1, 2, 3, 4, 5],
    [2, 1, 2, 3, 2, 4, 2, 5],
    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5],
    // 새로운 수포자의 패턴
];
```

## ⭐️ 시간복잡도
- O(n) - n은 문제 수
- 각 문제마다 3번의 비교 연산
- 패턴 길이와 무관하게 일정한 시간 복잡도