# 주식가격

**출처**: 프로그래머스 Lv.2  
**분류**: 스택/큐  
**난이도**: ⭐⭐

## 📋 문제 설명

초 단위로 기록된 주식가격이 담긴 배열 `prices`가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

---

## 🚫 제한사항

- prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
- prices의 길이는 2 이상 100,000 이하입니다.

---

## 📥 입출력 예

| prices          | return          |
| --------------- | --------------- |
| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |

---

## 📥 입출력 예 설명

- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다. → 4초간 유지
- 2초 시점의 ₩2는 끝까지 가격이 떨어지지 않았습니다. → 3초간 유지
- 3초 시점의 ₩3는 1초 뒤에 가격이 떨어집니다. (₩3 → ₩2) → 1초간 유지
- 4초 시점의 ₩2는 1초간 유지됩니다. (₩2 → ₩3이니까 떨어지지 않음) → 1초간 유지
- 5초 시점의 ₩3는 마지막이므로 → 0초

---

## 💡 풀이 접근

### 방법 1: 이중 for문 (단순 접근) ⭐ 추천 (처음에)

각 시점마다 뒤를 확인해서 가격이 떨어지는 시점 찾기

```typescript
[1, 2, 3, 2, 3]
 ↑
 i=0: 1과 비교 → 2(유지), 3(유지), 2(유지), 3(유지) → 4초
 
    ↑
 i=1: 2와 비교 → 3(유지), 2(유지), 3(유지) → 3초
 
       ↑
 i=2: 3과 비교 → 2(떨어짐!) → 1초
```

**시간 복잡도**: O(n²)

### 방법 2: 스택 사용 (효율적) 🔥

스택에 인덱스를 저장하고, 가격이 떨어질 때 계산

```typescript
스택에 인덱스를 저장
가격이 떨어지면 → 스택에서 pop하며 시간 계산
```

**시간 복잡도**: O(n)

---

## 🎯 단순 접근 (이중 for문)

```typescript
function solution(prices: number[]): number[] {
  const answer: number[] = [];
  
  for (let i = 0; i < prices.length; i++) {
    let count = 0;
    
    // i 이후의 가격들 확인
    for (let j = i + 1; j < prices.length; j++) {
      count++;
      
      // 가격이 떨어지면 중단
      if (prices[i] > prices[j]) {
        break;
      }
    }
    
    answer.push(count);
  }
  
  return answer;
}
```

---

## 🔍 동작 과정

### prices = [1, 2, 3, 2, 3]

```typescript
i=0 (가격 1):
  j=1: 1 ≤ 2 (유지) count=1
  j=2: 1 ≤ 3 (유지) count=2
  j=3: 1 ≤ 2 (유지) count=3
  j=4: 1 ≤ 3 (유지) count=4
  → 4초

i=1 (가격 2):
  j=2: 2 ≤ 3 (유지) count=1
  j=3: 2 ≤ 2 (유지) count=2
  j=4: 2 ≤ 3 (유지) count=3
  → 3초

i=2 (가격 3):
  j=3: 3 > 2 (떨어짐!) count=1, break
  → 1초

i=3 (가격 2):
  j=4: 2 ≤ 3 (유지) count=1
  → 1초

i=4 (가격 3):
  뒤에 없음
  → 0초
```

---

## 💭 생각해볼 점

### 1. "떨어지지 않은 기간"의 의미
- 가격이 **유지되거나 상승**한 기간
- `prices[i] <= prices[j]` 인 기간

### 2. break의 중요성
- 가격이 한 번 떨어지면 더 이상 확인 불필요
- 떨어진 시점까지 카운트하고 종료

### 3. 마지막 요소
- 뒤에 비교할 것이 없으므로 무조건 0초

### 4. count 증가 위치
- `count++`는 **먼저 실행**
- 왜? 떨어진 시점도 포함해야 하니까

---

## 🔍 테스트 케이스

```typescript
// 기본 케이스
solution([1, 2, 3, 2, 3]) // [4, 3, 1, 1, 0]

// 계속 떨어지는 경우
solution([5, 4, 3, 2, 1]) // [1, 1, 1, 1, 0]

// 계속 오르는 경우
solution([1, 2, 3, 4, 5]) // [4, 3, 2, 1, 0]

// 같은 가격
solution([3, 3, 3, 3]) // [3, 2, 1, 0]

// 최소 길이
solution([1, 2]) // [1, 0]
```

---

## 🎓 사용할 메서드

```typescript
// 배열 순회
for (let i = 0; i < array.length; i++) { ... }

// 조건 비교
if (prices[i] > prices[j]) { break; }

// 배열 추가
answer.push(count);
```

---

## 📊 시간/공간 복잡도

### 이중 for문 방법
- **시간**: O(n²)
- **공간**: O(n)

### 스택 방법 (심화)
- **시간**: O(n)
- **공간**: O(n)

---

## ✅ 체크리스트

- [ ] 모든 테스트 케이스 통과
- [ ] break 위치 확인
- [ ] count++ 위치 확인 (떨어진 시점도 포함)
- [ ] 마지막 요소 처리 (0초)

---

## 🔗 관련 문제

- 기능개발 (이미 풀었음!)
- 짝지어 제거하기 (이미 풀었음!)

---

**💡 TIP**: 처음에는 이중 for문으로 풀어보세요! 이해하기 쉽고, 테스트도 통과합니다. 스택 방법은 나중에 최적화할 때 시도해보세요!

