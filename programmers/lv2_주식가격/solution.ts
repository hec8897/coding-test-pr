/**
 * 주식가격
 *
 * @param prices - 초 단위 주식가격 배열
 * @returns 각 시점의 가격이 떨어지지 않은 기간
 *
 * 풀이 시간: ___분
 *
 * 접근 방법:
 * 1. 이중 for문 사용
 * 2. 각 시점마다 뒤의 가격들과 비교
 * 3. 가격이 떨어지면 break
 *
 * 핵심:
 * - count++를 먼저 실행 (떨어진 시점도 포함)
 * - prices[i] > prices[j]일 때 break
 *
 * 시간 복잡도: O(n²)
 * 공간 복잡도: O(n)
 */

function solution(prices: number[]): number[] {
  const answer = [];
  for (let i = 0; i < prices.length; i++) {
    let count = 0;
    for (let j = i + 1; j < prices.length; j++) {
      count++;
      if (prices[i] > prices[j]) {
        break;
      }
    }
    answer.push(count);
  }

  return answer;
}

// ============================================
// 테스트 케이스
// ============================================

console.log("=== 주식가격 테스트 ===\n");

// 테스트 1: 기본 케이스
console.log("테스트 1:", solution([1, 2, 3, 2, 3]));
// 예상: [4, 3, 1, 1, 0]
// 1: 끝까지 유지 (4초)
// 2: 끝까지 유지 (3초)
// 3: 다음에 2로 떨어짐 (1초)
// 2: 다음에 3으로 상승 (1초)
// 3: 마지막 (0초)

// 테스트 2: 계속 떨어지는 경우
console.log("테스트 2:", solution([5, 4, 3, 2, 1]));
// 예상: [1, 1, 1, 1, 0]
// 모두 바로 다음에 떨어짐

// 테스트 3: 계속 오르는 경우
console.log("테스트 3:", solution([1, 2, 3, 4, 5]));
// 예상: [4, 3, 2, 1, 0]
// 모두 끝까지 유지

// 테스트 4: 같은 가격
console.log("테스트 4:", solution([3, 3, 3, 3]));
// 예상: [3, 2, 1, 0]

// 테스트 5: 최소 길이
console.log("테스트 5:", solution([1, 2]));
// 예상: [1, 0]

// 테스트 6: 복잡한 케이스
console.log("테스트 6:", solution([5, 8, 6, 2, 4, 1]));
// 예상: ?
// 5: 8(유지), 6(유지), 2(떨어짐) → 3
// 8: 6(떨어짐) → 1
// 6: 2(떨어짐) → 1
// 2: 4(유지), 1(떨어짐) → 2
// 4: 1(떨어짐) → 1
// 1: 마지막 → 0
// [3, 1, 1, 2, 1, 0]

// ============================================
// 실행 방법
// ============================================
// ts-node solution.ts
