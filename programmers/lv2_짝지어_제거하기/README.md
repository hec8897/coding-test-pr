# 짝지어 제거하기

**출처**: 프로그래머스 Lv.2  
**분류**: 스택  
**난이도**: ⭐⭐

## 📋 문제 설명

알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그 다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 성공적으로 수행할 수 있으면 1을, 아니면 0을 리턴하는 함수를 완성해 주세요.

---

## 🚫 제한사항

- 문자열의 길이 : 1,000,000 이하의 자연수
- 문자열은 모두 소문자로 이루어져 있습니다.

---

## 📥 입출력 예

| s      | result |
| ------ | ------ |
| "baabaa" | 1      |
| "cdcd"   | 0      |

---

## 📥 입출력 예 설명

### 예제 #1
- b**aa**baa → b**bb**aa → **aa** → 성공!
- 모두 제거 가능하므로 1 반환

### 예제 #2
- cd cd → 제거할 짝이 없음
- 실패하므로 0 반환

---

## 💡 풀이 접근

### 스택(Stack) 활용 ⭐ 추천

**핵심 아이디어**:
1. 문자를 하나씩 확인
2. 스택의 맨 위 문자와 현재 문자가 같으면 → pop (제거)
3. 다르면 → push (추가)
4. 최종적으로 스택이 비어있으면 성공!

```typescript
// 예: "baabaa"
stack = []

'b' → stack = ['b']
'a' → stack = ['b', 'a']
'a' → 같음! pop → stack = ['b']
'b' → 같음! pop → stack = []
'a' → stack = ['a']
'a' → 같음! pop → stack = []

최종: stack이 비어있음 → 성공 (1)
```

**시간 복잡도**: O(n)
**공간 복잡도**: O(n)

---

## 🎯 핵심 패턴

### 스택의 특징
- LIFO (Last In First Out)
- 가장 최근 요소와 비교하는 문제에 적합

### 비교 패턴
```typescript
const stack = [];

for (let char of s) {
  if (stack.length > 0 && stack[stack.length - 1] === char) {
    // 같으면 제거
    stack.pop();
  } else {
    // 다르면 추가
    stack.push(char);
  }
}
```

---

## 🔍 테스트 케이스

```typescript
// 기본 케이스
solution("baabaa") // 1

// 실패 케이스
solution("cdcd") // 0

// 엣지 케이스
solution("aa") // 1 (전부 제거)
solution("a") // 0 (제거 불가)
solution("") // 1 (이미 비어있음)
solution("abba") // 1
```

---

## 💭 생각해볼 점

1. **왜 스택을 사용할까?**
   - 연속된 같은 문자를 제거 → 가장 최근 문자와 비교 필요
   - 배열로 일일이 확인하면 O(n²)
   - 스택으로 한 번만 순회하면 O(n)

2. **배열 대신 문자열 처리는?**
   - 문자열은 immutable → 매번 새로 생성 (느림)
   - 배열(스택)은 mutable → push/pop이 빠름

3. **효율성 테스트**
   - 문자열 길이: 최대 1,000,000
   - O(n²) 알고리즘은 시간 초과
   - O(n) 알고리즘 필수

---

## 🎓 사용할 메서드

```typescript
// 배열 (스택으로 사용)
const stack = [];
stack.push(item);           // 추가
stack.pop();                // 제거 및 반환
stack[stack.length - 1];    // 맨 위 확인 (peek)
stack.length;               // 크기

// 문자열
for (let char of string) { ... }  // 순회
```

---

## 📊 시간/공간 복잡도

- **시간**: O(n) - 문자열을 한 번만 순회
- **공간**: O(n) - 최악의 경우 스택에 모든 문자 저장

---

## ✅ 체크리스트

- [ ] 모든 테스트 케이스 통과
- [ ] 효율성 테스트 통과 (중요!)
- [ ] 엣지 케이스 처리 (빈 문자열, 문자 1개)
- [ ] 스택의 맨 위 요소 확인 방법 이해

---

## 🔗 관련 문제

- 올바른 괄호 (이미 풀었음!)
- 같은 숫자는 싫어 (이미 풀었음!)

---

**💡 TIP**: 이미 풀었던 "올바른 괄호"와 매우 유사한 패턴입니다. 스택의 맨 위 요소와 현재 요소를 비교하는 것이 핵심!

