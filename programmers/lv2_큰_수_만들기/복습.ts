/**
 * 🔄 [Lv.2] 큰 수 만들기 - 복습
 *
 * 📌 문제 요약:
 * - 숫자에서 k개를 제거했을 때 가장 큰 수 만들기
 * - 예: "1924"에서 2개 제거 → "94"
 *
 * 🎯 핵심 개념:
 * - 그리디 알고리즘
 * - 스택 (Stack)
 * - 문자열 처리
 *
 * 💡 힌트 (막히면 하나씩 펼쳐보세요!):
 *
 * [힌트 1] 어떤 전략으로 큰 수를 만들까?
 * - 앞자리가 클수록 큰 수!
 * - 94 > 92 > 24 > 19 > 14 > 12
 * - 작은 숫자를 제거하고 큰 숫자를 앞에!
 *
 * [힌트 2] 어떻게 작은 숫자를 찾을까?
 * - 현재 숫자보다 작은 이전 숫자를 제거
 * - "1924" → 9가 들어올 때 1 제거!
 * - "924" → 4가 들어올 때 2 제거!
 *
 * [힌트 3] 어떤 자료구조를 사용할까?
 * - 스택(Stack)!
 * - 마지막 숫자(top)와 현재 숫자를 비교
 * - top < 현재 → top 제거(pop)
 *
 * [힌트 4] 제거 개수는 어떻게 관리?
 * - removeCount 변수로 추적
 * - removeCount < k 일 때만 제거
 * - k개 제거하면 중단
 *
 * [힌트 5] 특수 케이스는?
 * - 내림차순: "9876" k=2 → "98"
 * - 같은 숫자: "1111" k=2 → "11"
 * - 제거를 못하면? → 뒤에서 k개 제거!
 */

// ============================================
// 🚀 여기서부터 코드를 작성해보세요!
// ============================================

function solution(number: string, k: number): string {
  // 1️⃣ 스택과 제거 카운터 초기화

  // 2️⃣ 숫자를 하나씩 순회
  // for (const num of number) {
  //   // 스택의 top이 현재 숫자보다 작으면 제거
  //   while (조건들) {
  //     // 스택에서 제거
  //     // 제거 카운터 증가
  //   }
  //   // 현재 숫자를 스택에 추가
  // }

  // 3️⃣ 남은 개수 처리 (뒤에서 제거)
  // while (removeCount < k) {
  //   // 스택에서 제거
  //   // 카운터 증가
  // }

  // 4️⃣ 스택을 문자열로 변환하여 반환

  return ""; // TODO: 결과 반환
}

// ============================================
// ✅ 테스트 케이스
// ============================================

console.log("=== 큰 수 만들기 복습 테스트 ===\n");

console.log("테스트 1:");
console.log('number: "1924", k: 2');
console.log("예상 결과: 94");
console.log("실제 결과:", solution("1924", 2));
console.log();

console.log("테스트 2:");
console.log('number: "1231234", k: 3');
console.log("예상 결과: 3234");
console.log("실제 결과:", solution("1231234", 3));
console.log();

console.log("테스트 3:");
console.log('number: "4177252841", k: 4');
console.log("예상 결과: 775841");
console.log("실제 결과:", solution("4177252841", 4));
console.log();

console.log("테스트 4 (내림차순):");
console.log('number: "9876", k: 2');
console.log("예상 결과: 98 (뒤에서 2개 제거)");
console.log("실제 결과:", solution("9876", 2));
console.log();

console.log("테스트 5 (같은 숫자):");
console.log('number: "1111", k: 2');
console.log("예상 결과: 11 (뒤에서 2개 제거)");
console.log("실제 결과:", solution("1111", 2));

/**
 * 💭 복습 체크리스트
 * ------------------------------------------
 * [ ] 문제를 읽고 이해했나요?
 * [ ] 그리디 전략을 이해했나요? (앞자리가 클수록 큰 수)
 * [ ] 스택의 필요성을 이해했나요?
 * [ ] while 조건 3가지를 모두 넣었나요?
 *     - stack.length > 0
 *     - removeCount < k
 *     - stack[stack.length - 1] < num
 * [ ] 제거 개수를 추적했나요? (removeCount)
 * [ ] 특수 케이스를 처리했나요? (뒤에서 제거)
 * [ ] stack.join('')으로 문자열 변환했나요?
 */

/**
 * 📝 복습 노트 작성 공간
 * ------------------------------------------
 * 이번 복습에서 배운 점:
 * -
 *
 * 어려웠던 부분:
 * -
 *
 * 다음에 주의할 점:
 * -
 */

// ============================================
// 💡 정답 코드 (막히면 참고하세요!)
// ============================================

/*

function solution(number: string, k: number): string {
  // 1. 스택과 제거 카운터 초기화
  const stack: string[] = [];
  let removeCount = 0;

  // 2. 숫자를 하나씩 순회
  for (const num of number) {
    // 스택의 top이 현재 숫자보다 작으면 제거
    while (
      stack.length > 0 &&           // 스택이 비어있지 않고
      removeCount < k &&            // 아직 제거할 개수가 남았고
      stack[stack.length - 1] < num // top이 현재 숫자보다 작으면
    ) {
      stack.pop();        // 제거
      removeCount++;      // 카운터 증가
    }
    stack.push(num);      // 현재 숫자 추가
  }

  // 3. 남은 개수 처리 (뒤에서 제거)
  while (removeCount < k) {
    stack.pop();
    removeCount++;
  }

  // 4. 스택을 문자열로 변환
  return stack.join('');
}

*/

/**
 * 🎯 핵심 정리
 * ------------------------------------------
 *
 * 1️⃣ 그리디 전략
 *    - 목표: 가장 큰 수 만들기
 *    - 방법: 앞자리가 클수록 큰 수
 *    - 실행: 작은 숫자 제거, 큰 숫자 유지
 *
 * 2️⃣ 스택 사용 이유
 *    - 이전 숫자들을 관리
 *    - top과 현재 숫자를 비교
 *    - 작은 숫자를 쉽게 제거(pop)
 *
 * 3️⃣ 알고리즘 흐름
 *    ① 숫자를 하나씩 확인
 *    ② 스택 top < 현재 숫자 → top 제거
 *    ③ 현재 숫자를 스택에 추가
 *    ④ k개 제거할 때까지 반복
 *    ⑤ 남은 개수는 뒤에서 제거
 *
 * 4️⃣ while 조건 (3가지 모두 필요!)
 *    - stack.length > 0
 *      → 스택이 비어있으면 제거할 게 없음
 *    - removeCount < k
 *      → k개 이상 제거하면 안 됨
 *    - stack[stack.length - 1] < num
 *      → top이 현재보다 작아야 제거할 이유가 있음
 *
 * 5️⃣ 특수 케이스
 *    - 내림차순 숫자 (9876)
 *      → while 문에서 제거를 못함
 *      → 뒤에서 k개 제거
 *    - 같은 숫자 (1111)
 *      → 역시 제거를 못함
 *      → 뒤에서 k개 제거
 *
 * 6️⃣ 예시: "1924", k = 2
 *
 *    초기: stack = [], removeCount = 0
 *
 *    1. num = '1'
 *       - stack = ['1']
 *
 *    2. num = '9'
 *       - stack.top = '1' < '9' → 1 제거!
 *       - removeCount = 1
 *       - stack = ['9']
 *
 *    3. num = '2'
 *       - stack.top = '9' > '2' → 유지
 *       - stack = ['9', '2']
 *
 *    4. num = '4'
 *       - stack.top = '2' < '4' → 2 제거!
 *       - removeCount = 2 (k와 같음)
 *       - stack = ['9', '4']
 *
 *    결과: "94" ✨
 *
 * 7️⃣ 실수 주의
 *    - while 조건에 3가지 모두 넣기
 *    - removeCount 증가 잊지 않기
 *    - 남은 개수 처리 (두 번째 while)
 *    - stack.join('') 문자열 변환
 *    - stack[stack.length - 1] (top 접근)
 *
 * 8️⃣ 시간 복잡도
 *    - 모든 숫자 순회: O(n)
 *    - 각 숫자는 최대 1번 push, 1번 pop: O(n)
 *    - 전체: O(n) ✅
 *
 * 9️⃣ 공간 복잡도
 *    - 스택에 최대 n개 저장: O(n)
 *
 * 🔟 왜 그리디인가?
 *    - 현재 숫자를 보고 즉시 판단
 *    - "지금 제거하는 게 최선인가?"
 *    - 뒤돌아보지 않고 진행
 *    - 지역 최적 → 전역 최적
 */

/**
 * 🎓 추가 학습: 스택 패턴
 * ------------------------------------------
 *
 * 이 문제는 "스택 + 그리디" 패턴의 대표 문제입니다.
 *
 * 비슷한 패턴의 문제:
 * - 주식 가격 (스택으로 이전 값 관리)
 * - 올바른 괄호 (스택으로 짝 맞추기)
 * - 크레인 인형뽑기 (스택으로 같은 값 제거)
 *
 * 핵심 포인트:
 * - 스택은 "이전 값"을 관리하는 도구
 * - top과 현재 값을 비교하여 판단
 * - while로 조건 만족할 때까지 제거
 */
