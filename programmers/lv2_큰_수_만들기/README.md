# [Lv.2] 큰 수 만들기

## 📌 문제 설명

어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

---

## 🔒 제한사항

- number는 2자리 이상, 1,000,000자리 이하인 숫자입니다.
- k는 1 이상 `number의 자릿수` 미만인 자연수입니다.

---

## 📥 입출력 예

| number       | k   | return   |
| ------------ | --- | -------- |
| "1924"       | 2   | "94"     |
| "1231234"    | 3   | "3234"   |
| "4177252841" | 4   | "775841" |

---

## 📥 입출력 예 설명

### 예제 #1
- "1924"에서 2개 제거
- 가능한 수: 19, 12, 14, 92, 94, 24
- 최댓값: **94**

### 예제 #2
- "1231234"에서 3개 제거
- 최댓값: **3234**

### 예제 #3
- "4177252841"에서 4개 제거
- 최댓값: **775841**

---

## 💡 핵심 아이디어

### 🎯 그리디 전략

**"앞자리가 클수록 큰 수다!"**

```
1924에서 2개 제거

앞에서부터:
1 < 9 → 1 제거!  → "924"
9 > 2 → 9 유지
2 < 4 → 2 제거!  → "94"

결과: 94 ✨
```

### 📚 스택 활용

**"현재 숫자보다 작은 숫자를 스택에서 제거하기"**

```
number = "1924", k = 2

스택 과정:
1. 스택: [1]
2. 9가 들어옴 → 1 < 9 이므로 1 제거 (k=1)
   스택: [9]
3. 2가 들어옴 → 9 > 2 이므로 2 추가
   스택: [9, 2]
4. 4가 들어옴 → 2 < 4 이므로 2 제거 (k=0)
   스택: [9, 4]

결과: "94"
```

---

## 🛠️ 알고리즘 흐름

### Step 1: 스택 준비
```typescript
const stack: string[] = [];
let removeCount = 0;  // 제거한 개수
```

### Step 2: 숫자를 하나씩 확인
```typescript
for (let num of number) {
  // 스택의 top이 현재 숫자보다 작으면 제거
  while (stack.length > 0 && 
         stack[stack.length - 1] < num && 
         removeCount < k) {
    stack.pop();
    removeCount++;
  }
  stack.push(num);
}
```

### Step 3: 남은 개수 처리
```typescript
// k개를 다 제거하지 못했다면?
// 예: "9999" k=2 → 뒤에서 2개 제거
while (removeCount < k) {
  stack.pop();
  removeCount++;
}
```

### Step 4: 결과 반환
```typescript
return stack.join('');
```

---

## 🔍 예시 상세 추적

### 예제: "1924", k = 2

```
초기: stack = [], removeCount = 0

1. num = '1'
   - stack이 비었음
   - stack = ['1']

2. num = '9'
   - stack.top = '1' < '9' (제거!)
   - removeCount = 1
   - stack = ['9']

3. num = '2'
   - stack.top = '9' > '2' (유지)
   - stack = ['9', '2']

4. num = '4'
   - stack.top = '2' < '4' (제거!)
   - removeCount = 2 (k와 같음, 종료)
   - stack = ['9', '4']

결과: "94" ✨
```

---

## 🤔 특수 케이스 주의!

### Case 1: 내림차순 숫자
```
number = "9876", k = 2

모든 숫자를 순회해도 제거를 못 함!
(뒤의 숫자가 항상 더 작음)

해결: 뒤에서 k개 제거
→ "98"
```

### Case 2: 같은 숫자
```
number = "1111", k = 2

역시 제거를 못 함!

해결: 뒤에서 k개 제거
→ "11"
```

---

## ⏰ 복잡도

### 시간 복잡도
- 모든 숫자를 한 번씩 확인: O(n)
- 각 숫자는 최대 1번 push, 1번 pop: O(n)
- **전체: O(n)**

### 공간 복잡도
- 스택에 최대 n개 저장: O(n)

---

## ✅ 체크리스트

- [ ] 스택을 선언했나요?
- [ ] `removeCount` 변수로 제거 개수를 추적하나요?
- [ ] while 조건에 3가지가 모두 들어갔나요?
  - `stack.length > 0`
  - `stack[stack.length - 1] < num`
  - `removeCount < k`
- [ ] 남은 제거 개수를 처리했나요? (뒤에서 제거)
- [ ] `stack.join('')`으로 문자열 반환하나요?

---

## 🎓 핵심 개념

- ⭐⭐ **그리디 알고리즘** (Greedy)
- ⭐⭐ **스택** (Stack)
- ⭐ **문자열 처리**

---

## 💭 그리디 사고 과정

1. **목표**: 가장 큰 수 만들기
2. **전략**: 앞자리가 클수록 큰 수
3. **방법**: 작은 숫자를 제거하고 큰 숫자 유지
4. **도구**: 스택으로 이전 숫자 관리

---

## 🚀 같이 풀어봅시다!

힌트를 보지 말고 먼저 시도해보세요!
막히면 위의 알고리즘 흐름을 참고하세요! 😊

**Tip**: 
- 스택의 top과 현재 숫자를 비교하는 게 핵심!
- `removeCount < k` 조건을 잊지 마세요!
- 마지막에 남은 개수 처리를 잊지 마세요!

