# 하노이의 탑

## 📌 문제 설명

하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 서로 다른 크기의 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다.

게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 있는 원판들을 모두 다른 기둥으로 옮기는 것입니다:

1. 한 번에 하나의 원판만 옮길 수 있습니다.
2. 큰 원판이 작은 원판 위에 있어서는 안 됩니다.

원판의 개수 n이 매개변수로 주어질 때, n개의 원판을 1번 기둥에서 3번 기둥으로 최소 횟수로 옮기는 방법을 return 하도록 solution 함수를 완성해주세요.

## 제한사항

- n은 15이하의 자연수 입니다.

## 입출력 예

| n   | return                                            |
| --- | ------------------------------------------------- |
| 2   | [[1,2], [1,3], [2,3]]                             |
| 3   | [[1,3], [1,2], [3,2], [1,3], [2,1], [2,3], [1,3]] |

## 💡 풀이 방법

### 핵심 아이디어

**하노이의 탑은 재귀의 전형적인 예시입니다!**

n개의 원판을 1번 기둥에서 3번 기둥으로 옮기는 과정:

1. **n-1개의 원판**을 1번에서 2번으로 옮김 (보조 기둥)
2. **가장 큰 원판**을 1번에서 3번으로 옮김
3. **n-1개의 원판**을 2번에서 3번으로 옮김

### 재귀 함수 구조

```typescript
function hanoi(n: number, from: number, to: number, via: number): number[][] {
  // 1. 종료 조건
  if (n === 1) {
    return [[from, to]];
  }

  // 2. 재귀 호출
  const result = [];

  // n-1개를 from에서 via로 (to를 보조로)
  result.push(...hanoi(n - 1, from, via, to));

  // 가장 큰 원판을 from에서 to로
  result.push([from, to]);

  // n-1개를 via에서 to로 (from을 보조로)
  result.push(...hanoi(n - 1, via, to, from));

  return result;
}
```

## 🔍 단계별 실행 과정

### n = 2일 때

```
hanoi(2, 1, 3, 2)
├── hanoi(1, 1, 2, 3) → [[1, 2]]
├── [1, 3] (가장 큰 원판)
└── hanoi(1, 2, 3, 1) → [[2, 3]]

결과: [[1, 2], [1, 3], [2, 3]]
```

### n = 3일 때

```
hanoi(3, 1, 3, 2)
├── hanoi(2, 1, 2, 3)
│   ├── hanoi(1, 1, 3, 2) → [[1, 3]]
│   ├── [1, 2] (중간 원판)
│   └── hanoi(1, 3, 2, 1) → [[3, 2]]
├── [1, 3] (가장 큰 원판)
└── hanoi(2, 2, 3, 1)
    ├── hanoi(1, 2, 1, 3) → [[2, 1]]
    ├── [2, 3] (중간 원판)
    └── hanoi(1, 1, 3, 2) → [[1, 3]]

결과: [[1,3], [1,2], [3,2], [1,3], [2,1], [2,3], [1,3]]
```

## 💻 완전한 코드

```typescript
function solution(n: number): number[][] {
  function hanoi(n: number, from: number, to: number, via: number): number[][] {
    if (n === 1) {
      return [[from, to]];
    }

    const result = [];

    // n-1개를 from에서 via로
    result.push(...hanoi(n - 1, from, via, to));

    // 가장 큰 원판을 from에서 to로
    result.push([from, to]);

    // n-1개를 via에서 to로
    result.push(...hanoi(n - 1, via, to, from));

    return result;
  }

  return hanoi(n, 1, 3, 2);
}
```

## 🧠 핵심 개념

### 1. 재귀의 분할 정복

- **큰 문제를 작은 문제로 분할**
- **n개 → n-1개 → n-2개 → ... → 1개**
- **각 단계에서 동일한 패턴 반복**

### 2. 기둥 역할

- **from**: 출발 기둥
- **to**: 도착 기둥
- **via**: 보조 기둥 (임시 저장)

### 3. 최적 해

- **최소 이동 횟수**: 2^n - 1
- **n=2**: 3번 이동
- **n=3**: 7번 이동
- **n=4**: 15번 이동

## 🎯 재귀의 핵심 원리

### 1. 종료 조건 (Base Case)

```typescript
if (n === 1) {
  return [[from, to]]; // 가장 간단한 경우
}
```

### 2. 재귀 호출 (Recursive Case)

```typescript
// 문제를 작게 나누어 해결
hanoi(n - 1, from, via, to); // 작은 문제 1
// 중간 처리
hanoi(n - 1, via, to, from); // 작은 문제 2
```

### 3. 결과 조합

```typescript
// 작은 문제들의 해를 조합하여 큰 문제 해결
result.push(...hanoi(n - 1, from, via, to));
result.push([from, to]);
result.push(...hanoi(n - 1, via, to, from));
```

## ⚠️ 주의사항

### 1. 스택 오버플로우

- **n이 클 때**: 재귀 깊이가 깊어짐
- **n ≤ 15**: 문제 제한으로 안전

### 2. 메모리 사용량

- **결과 배열**: 2^n - 1개의 요소
- **n=15**: 32,767개의 이동

### 3. 시간복잡도

- **O(2^n)**: 각 원판마다 2번의 재귀 호출
- **n=15**: 약 32,767번의 연산

## 💡 배운 점

1. **재귀의 분할 정복**: 큰 문제를 작은 문제로 분할
2. **문제 분해**: 복잡한 문제를 단계별로 해결
3. **패턴 인식**: 동일한 패턴의 반복
4. **최적 해**: 재귀로 최적 해를 찾는 방법

## 🎯 실전 팁

- **재귀는 분할 정복에 강력**
- **종료 조건을 명확히 정의**
- **문제를 작게 나누는 방법 찾기**
- **결과를 조합하는 방법 고민**

## ⭐️ 시간복잡도

- **시간복잡도**: O(2^n)
- **공간복잡도**: O(n) - 재귀 스택
- **결과 크기**: O(2^n) - 이동 횟수

## 🚀 다른 접근법

### 반복문 (비추천)

```typescript
// 하노이의 탑은 재귀가 가장 자연스러움
// 반복문으로는 복잡하고 이해하기 어려움
```

### 메모이제이션 (불필요)

```typescript
// 하노이의 탑은 중복 계산이 없음
// 각 단계가 유일한 경로
```

## 🎯 요약

**하노이의 탑은 재귀의 완벽한 예시입니다!**

1. **분할 정복**: n개 → n-1개 → ... → 1개
2. **패턴 반복**: 동일한 3단계 과정
3. **재귀 구조**: 종료 조건 + 재귀 호출
4. **최적 해**: 2^n - 1번의 이동

**재귀를 이해하는 가장 좋은 문제입니다!** 😊
