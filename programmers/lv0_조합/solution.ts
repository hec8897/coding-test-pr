/**
 * [Lv.0] ì¡°í•© - ì¬ê·€ íŒ¨í„´ 3: ë°±íŠ¸ë˜í‚¹
 *
 * ğŸ¯ ë¬¸ì œ: nê°œ ì¤‘ rê°œ ë½‘ëŠ” ì¡°í•©ì˜ ê°œìˆ˜
 *
 * ğŸ“Œ ì¬ê·€ íŒ¨í„´: ë°±íŠ¸ë˜í‚¹
 * - ì„ íƒ â†’ ì§„í–‰ â†’ ì·¨ì†Œ (ë˜ëŒì•„ê°€ê¸°)
 * - push â†’ ì¬ê·€ â†’ pop
 * - ë¶ˆí•„ìš”í•œ ê²½ë¡œ ê°€ì§€ì¹˜ê¸°
 *
 * ğŸ’¡ í•µì‹¬:
 * 1. ì¢…ë£Œ ì¡°ê±´: ì„ íƒí•œ ê°œìˆ˜ê°€ rê°œ
 * 2. for ë£¨í”„: ë‹¤ìŒ ì„ íƒì§€ íƒìƒ‰
 * 3. ë°±íŠ¸ë˜í‚¹: pop()ìœ¼ë¡œ ì„ íƒ ì·¨ì†Œ
 *
 * â° ì‹œê°„ ë³µì¡ë„: O(nCr)
 * ğŸ’¾ ê³µê°„ ë³µì¡ë„: O(r) - Call Stack
 */

function solution(arr: number[], r: number): number {
  let count = 0;

  // TODO: ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ êµ¬í˜„í•´ë³´ì„¸ìš”!
  function dfs(start: number, current: number[]) {
    if (current.length === r) {
      count++;
      return;
    }

    for (let i = start; i < arr.length; i++) {
      current.push(arr[i]);
      dfs(i + 1, current);
      current.pop();
    }
  }

  dfs(0, []);
  return count;
}

// í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
console.log("=== ì¡°í•© (ë°±íŠ¸ë˜í‚¹) í…ŒìŠ¤íŠ¸ ===\n");

console.log("í…ŒìŠ¤íŠ¸ 1:");
console.log("arr: [1, 2, 3, 4], r: 2");
console.log("ì˜ˆìƒ ê²°ê³¼: 6");
console.log("ì‹¤ì œ ê²°ê³¼:", solution([1, 2, 3, 4], 2));
console.log("ì¡°í•©:");
console.log("  [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]");
console.log();

console.log("í…ŒìŠ¤íŠ¸ 2:");
console.log("arr: [1, 2, 3], r: 1");
console.log("ì˜ˆìƒ ê²°ê³¼: 3");
console.log("ì‹¤ì œ ê²°ê³¼:", solution([1, 2, 3], 1));
console.log("ì¡°í•©:");
console.log("  [1], [2], [3]");
console.log();

console.log("í…ŒìŠ¤íŠ¸ 3:");
console.log("arr: [1, 2, 3], r: 3");
console.log("ì˜ˆìƒ ê²°ê³¼: 1");
console.log("ì‹¤ì œ ê²°ê³¼:", solution([1, 2, 3], 3));
console.log("ì¡°í•©:");
console.log("  [1,2,3]");

/**
 * ğŸ’¡ ë°±íŠ¸ë˜í‚¹ ì‹¤í–‰ ê³¼ì • ì´í•´í•˜ê¸°
 *
 * arr = [1, 2, 3], r = 2
 *
 *              dfs(0, [])
 *          /      |      \
 *     push(1)  push(2)  push(3)
 *        â†“        â†“        â†“
 *   dfs(1,[1]) dfs(2,[2]) dfs(3,[3])
 *     /    \       |
 * push(2) push(3) push(3)
 *    â†“      â†“       â†“
 * [1,2]âœ¨ [1,3]âœ¨ [2,3]âœ¨
 *    â†“      â†“       â†“
 * pop(2)  pop(3)  pop(3)
 *    â†“      â†“       â†“
 *  [1]     [1]     [2]
 *    â†“
 * pop(1)
 *    â†“
 *   []
 *
 *
 * ğŸ”‘ í•µì‹¬:
 *
 * 1. push: ì„ íƒí•˜ê¸°
 *    current.push(arr[i])
 *    â†’ í˜„ì¬ ìˆ«ìë¥¼ ì¡°í•©ì— ì¶”ê°€
 *
 * 2. ì¬ê·€: ë‹¤ìŒ ë‹¨ê³„ë¡œ
 *    dfs(i + 1, current)
 *    â†’ ë‹¤ìŒ ìˆ«ì ì„ íƒí•˜ëŸ¬ ê°€ê¸°
 *
 * 3. pop: ì·¨ì†Œí•˜ê¸° (ë°±íŠ¸ë˜í‚¹!)
 *    current.pop()
 *    â†’ ë°©ê¸ˆ ì„ íƒí•œ ìˆ«ì ì œê±°
 *    â†’ ë‹¤ë¥¸ ì„ íƒì§€ ì‹œë„í•˜ê¸° ìœ„í•´
 *
 *
 * ğŸ“Š ì„ íƒê³¼ ì·¨ì†Œ ì¶”ì :
 *
 * [1, 2, 3]ì—ì„œ 2ê°œ ë½‘ê¸°
 *
 * 1. [] â†’ push(1) â†’ [1]
 * 2. [1] â†’ push(2) â†’ [1,2] âœ¨ count++
 * 3. [1,2] â†’ pop(2) â†’ [1]
 * 4. [1] â†’ push(3) â†’ [1,3] âœ¨ count++
 * 5. [1,3] â†’ pop(3) â†’ [1]
 * 6. [1] â†’ pop(1) â†’ []
 * 7. [] â†’ push(2) â†’ [2]
 * 8. [2] â†’ push(3) â†’ [2,3] âœ¨ count++
 * 9. [2,3] â†’ pop(3) â†’ [2]
 * 10. [2] â†’ pop(2) â†’ []
 *
 * ê²°ê³¼: count = 3
 *
 *
 * ğŸŒ² ì™œ start íŒŒë¼ë¯¸í„°ê°€ í•„ìš”í• ê¹Œ?
 *
 * startê°€ ì—†ìœ¼ë©´:
 * [1] â†’ [1,1], [1,2], [1,3] (ì¤‘ë³µ!)
 *
 * startê°€ ìˆìœ¼ë©´:
 * [1] â†’ [1,2], [1,3] (ì¤‘ë³µ ì—†ìŒ)
 * ì™œ? i + 1ë¶€í„° ì‹œì‘í•˜ë‹ˆê¹Œ ì´ì „ ì›ì†ŒëŠ” ì„ íƒ ì•ˆ í•¨!
 *
 *
 * ğŸ’­ ë¶„ê¸° ì¬ê·€ vs ë°±íŠ¸ë˜í‚¹
 *
 * ë¶„ê¸° ì¬ê·€ (íƒ€ê²Ÿ ë„˜ë²„):
 *   - ëª¨ë“  ê²½ë¡œë¥¼ ëê¹Œì§€ íƒìƒ‰
 *   - ê°’ì„ ë°˜í™˜í•´ì„œ í•©ì‚°
 *   - return plus + minus
 *
 * ë°±íŠ¸ë˜í‚¹ (ì¡°í•©):
 *   - ì¡°ê±´ ë§Œì¡±í•˜ë©´ ë˜ëŒì•„ê°€ê¸°
 *   - count ë³€ìˆ˜ë¡œ ê°œìˆ˜ ì„¸ê¸°
 *   - push/popìœ¼ë¡œ ìƒíƒœ ê´€ë¦¬
 *   - ë¶ˆí•„ìš”í•œ ê²½ë¡œëŠ” ê°€ì§€ì¹˜ê¸°
 */

export default solution;
