# 🔥 코딩테스트 30분 전 최종 체크리스트

> **시험 시작 전 5-10분 동안 이 문서를 빠르게 읽으세요!**

---

## ⏰ 시간 관리 전략

- ✅ **쉬운 문제부터!** lv1 → lv2 순서로
- ✅ **10분 고민해도 안 풀리면** → 다음 문제로 (나중에 돌아오기)
- ✅ **최소 3문제는 완성**하는 것을 목표로
- ✅ 디버깅 시간 확보: 문제당 5분 여유

---

## 🎯 유형별 핵심 패턴 (30초 복습)

### 1️⃣ Hash (Map/Set) - 가장 자주 나옴! ⭐⭐⭐

```typescript
// Map: 빈도수, 그룹화
const map = new Map();
map.set(key, (map.get(key) || 0) + 1);

// Set: 중복 제거, 존재 여부
const set = new Set(array);
set.has(value); // true/false
```

**대표 문제**: 완주하지 못한 선수, 폰켓몬, 전화번호 목록, 위장

---

### 2️⃣ 정렬 (Sort) ⭐⭐⭐

```typescript
// 오름차순
arr.sort((a, b) => a - b);

// 내림차순
arr.sort((a, b) => b - a);

// 커스텀 정렬
arr.sort((a, b) => {
  if (조건) return -1; // a를 앞으로
  return 1; // b를 앞으로
});
```

**대표 문제**: K번째수, 가장 큰 수, 최솟값 만들기

---

### 3️⃣ Stack ⭐⭐⭐

```typescript
const stack = [];
stack.push(item); // 추가
stack.pop(); // 제거
stack[stack.length - 1]; // Top 확인 (중요!)

// 패턴: 같은 것끼리 제거
if (stack.length === 0 || stack[stack.length - 1] !== current) {
  stack.push(current);
}
```

**대표 문제**: 올바른 괄호, 같은 숫자는 싫어, 짝지어 제거하기, 괄호 회전하기

---

### 4️⃣ Queue ⭐⭐

```typescript
const queue = [];
queue.push(item); // 뒤에 추가
queue.shift(); // 앞에서 제거

// 우선순위 큐 패턴
while (queue.length > 0) {
  const current = queue.shift();
  if (조건) {
    queue.push(current); // 뒤로 보내기
  } else {
    // 처리
  }
}
```

**대표 문제**: 프로세스, 기능개발, 주식가격

---

### 5️⃣ Greedy (탐욕) ⭐⭐

```typescript
// 패턴 1: 정렬 후 투 포인터
arr.sort((a, b) => a - b);
let left = 0,
  right = arr.length - 1;

// 패턴 2: 현재 최선의 선택
for (const item of items) {
  if (현재_최선의_조건) {
    선택();
  }
}
```

**대표 문제**: 체육복, 최솟값 만들기

---

### 6️⃣ DFS/재귀 ⭐⭐

```typescript
function dfs(index: number, state: any): number {
  // 1. 종료 조건 (Base Case)
  if (index === target) {
    return 조건 ? 1 : 0;
  }

  // 2. 재귀 호출 (모든 경우의 수)
  const case1 = dfs(index + 1, state1);
  const case2 = dfs(index + 1, state2);

  // 3. 결과 합치기
  return case1 + case2;
}
```

**대표 문제**: 타겟 넘버, 하노이의 탑

---

### 7️⃣ 완전탐색 (Brute Force) ⭐

```typescript
// 모든 경우의 수 확인
for (let i = 0; i < n; i++) {
  for (let j = 0; j < m; j++) {
    // 모든 조합 확인
  }
}

// 패턴 매칭 (반복되는 패턴)
for (let i = 0; i < arr.length; i++) {
  const patternIndex = i % pattern.length;
}
```

**대표 문제**: 모의고사, 소수 찾기

---

### 8️⃣ 구현/수학 ⭐

```typescript
// 올림/내림/반올림
Math.ceil(x); // 올림
Math.floor(x); // 내림
Math.round(x); // 반올림

// 최대/최소
Math.max(...array);
Math.min(...array);

// 나머지/몫
const 몫 = Math.floor(a / b);
const 나머지 = a % b;
```

---

## 🚨 자주 하는 실수 체크리스트

### ❌ 절대 하지 말 것

1. **`sort()` 숫자 정렬 시 비교함수 생략**

   ```typescript
   // ❌ 틀림
   [10, 2, 1].sort(); // [1, 10, 2] (문자열 정렬됨!)

   // ✅ 정답
   [10, 2, 1].sort((a, b) => a - b); // [1, 2, 10]
   ```

2. **스택 Top 확인할 때 `pop()` 사용**

   ```typescript
   // ❌ 틀림 (pop은 제거함!)
   if (stack.pop() === value) {
   }

   // ✅ 정답
   if (stack[stack.length - 1] === value) {
   }
   ```

3. **곱셈 초기값 0으로 설정**

   ```typescript
   // ❌ 틀림
   let answer = 0;
   answer *= something; // 항상 0!

   // ✅ 정답
   let answer = 1; // 곱셈은 1부터 시작
   ```

4. **`Math.ceil()` 괄호 실수**

   ```typescript
   // ❌ 틀림
   Math.ceil(100 - progress / speed); // 나눗셈 먼저 계산됨

   // ✅ 정답
   Math.ceil((100 - progress) / speed);
   ```

5. **배열 마지막 그룹 처리 누락**
   ```typescript
   // Queue/Array 순회 후
   answer.push(count); // ⭐ 마지막 그룹 꼭 추가!
   ```

---

## 🎯 문제 풀이 체크리스트

### 문제를 읽을 때

- [ ] 입력/출력 범위 확인 (1 ≤ n ≤ 1,000,000?)
- [ ] 시간 복잡도 추정 (O(n²) 가능한가?)
- [ ] 엣지 케이스 확인 (빈 배열? 0? 음수?)

### 코드를 작성할 때

- [ ] 변수명 명확하게 (i, j 보다는 의미 있는 이름)
- [ ] 초기값 올바르게 (곱셈=1, 덧셈=0, 최소값=Infinity)
- [ ] 인덱스 범위 체크 (0 ≤ i < length)
- [ ] 괄호 짝 맞추기

### 제출 전

- [ ] 예제 입력으로 직접 테스트
- [ ] 엣지 케이스 테스트 (빈 배열, 길이 1, 최대값)
- [ ] console.log 제거했는지 확인

---

## 💡 TypeScript 필수 메서드 (암기!)

### 배열

```typescript
arr.push(item); // 뒤에 추가
arr.pop(); // 뒤에서 제거
arr.shift(); // 앞에서 제거
arr.unshift(item); // 앞에 추가
arr.slice(start, end); // 부분 배열 (원본 유지)
arr.splice(start, count); // 부분 제거 (원본 변경)
arr.some(fn); // 하나라도 true면 true
arr.every(fn); // 모두 true면 true
arr.filter(fn); // 조건 만족하는 것만
arr.map(fn); // 각 요소 변환
arr.reduce(fn, init); // 누적 계산
```

### 문자열

```typescript
str.split(delimiter)     // 문자열 → 배열
arr.join(delimiter)      // 배열 → 문자열
str.slice(start, end)    // 부분 문자열
str.substring(start, end)// 부분 문자열 (음수 인덱스 불가)
str.charAt(index)        // 특정 위치 문자
str.startsWith(prefix)   // 접두사 확인
str.endsWith(suffix)     // 접미사 확인
str.toLowerCase()        // 소문자 변환
str.toUpperCase()        // 대문자 변환
str.replace(old, new)    // 첫 번째 매칭만 변경
str.replaceAll(old, new) // 모든 매칭 변경
```

---

## 🔥 시험장에서 마인드셋

### ✅ DO

- **침착하게!** 당황하면 아는 것도 틀림
- **예제 입력으로 손으로 풀어보기** (로직 검증)
- **주석으로 단계 먼저 작성** (구조 잡기)
- **모르는 문제는 과감히 넘기기** (시간 관리)

### ❌ DON'T

- 한 문제에 30분 이상 투자
- 완벽주의 (일단 돌아가게 만들고 개선)
- 처음부터 최적화 고민 (정확성 먼저)

---

## 🎯 마지막 한 마디

> **"지금까지 푼 문제들을 믿고, 침착하게 풀면 됩니다!"**
>
> **Hash, Stack, Queue, Sort, Greedy만 확실하면 3문제는 갑니다!**

---

## 📊 우선순위 공략 순서

1. **Hash 문제** (가장 자주 나옴, 쉬움)
2. **정렬 문제** (안정적으로 풀 수 있음)
3. **Stack/Queue** (패턴만 알면 쉬움)
4. **Greedy** (논리적 사고 필요, 중간 난이도)
5. **완전탐색** (시간만 있으면 풀 수 있음)
6. **DFS/재귀** (어려우면 마지막에)

---

## 🚀 시작 5분 전

- [ ] 화장실 다녀오기
- [ ] 손 풀기 (간단한 코드 타이핑)
- [ ] 심호흡 3회
- [ ] "나는 할 수 있다!" 💪

**Good Luck! 🍀 화이팅! 🔥**
