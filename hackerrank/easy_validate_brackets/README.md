# Validate Properly Nested Brackets

## 문제 정보

- **플랫폼**: HackerRank
- **레벨/난이도**: Easy
- **풀이 날짜**: 2025-10-27
- **재풀이**: ❌ (복습 예정)

## 문제 설명

괄호로 이루어진 문자열이 올바르게 중첩되었는지(properly nested) 확인하세요.

**괄호 종류:** `()`, `[]`, `{}`

### 올바른 경우

```
"()"        ✅
"()[]{}"    ✅
"{[]}"      ✅
"([{}])"    ✅
```

### 올바르지 않은 경우

```
"(]"        ❌ 짝이 맞지 않음
"([)]"      ❌ 순서가 잘못됨
"((("       ❌ 닫는 괄호 없음
")"         ❌ 여는 괄호 없음
```

### 제약사항

- 0 ≤ 문자열 길이 ≤ 10^5
- 문자열은 괄호 문자만 포함

## 접근 방법

1. **스택(배열) 준비**: 여는 괄호를 저장할 스택
2. **문자열 순회**: 한 글자씩 확인
3. **여는 괄호** `(`, `[`, `{` → 스택에 push
4. **닫는 괄호** `)`, `]`, `}`:
   - 스택이 비어있으면 → 0 반환 (닫을 괄호 없음)
   - 스택에서 pop하고 짝이 맞는지 확인
   - 짝이 안 맞으면 → 0 반환
5. **다른 문자** (알파벳, 숫자 등) → 무시
6. **모든 순회 완료 후**: 스택이 비어있으면 1, 아니면 0

## 시간복잡도

- **시간**: O(n) - 문자열을 한 번 순회
- **공간**: O(n) - 최악의 경우 모든 괄호가 여는 괄호 (스택에 저장)

## 풀이 코드

```typescript
function areBracketsProperlyMatched(code_snippet: string): number {
  const stack: string[] = [];
  const pairs = {
    ")": "(",
    "]": "[",
    "}": "{",
  };

  for (let char of code_snippet) {
    // 여는 괄호면 스택에 넣기
    if (char === "(" || char === "[" || char === "{") {
      stack.push(char);
    }
    // 닫는 괄호면 스택에서 꺼내서 짝 확인
    else if (char === ")" || char === "]" || char === "}") {
      // 스택이 비었으면 닫을 괄호가 없음
      if (stack.length === 0) {
        return 0;
      }

      // 스택에서 꺼내기
      const top = stack.pop();

      // 짝이 맞는지 확인
      if (top !== pairs[char]) {
        return 0;
      }
    }
    // 다른 문자는 무시
  }

  // 스택이 비어있으면 1, 아니면 0
  return stack.length === 0 ? 1 : 0;
}
```

## 핵심 개념

### 스택(Stack) 자료구조

**LIFO (Last In, First Out)**: 마지막에 들어간 게 먼저 나옴

```
여는 괄호 → push
닫는 괄호 → pop하고 짝이 맞는지 확인
```

### 알고리즘

1. 문자열을 하나씩 순회
2. **여는 괄호** `(`, `[`, `{` → 스택에 push
3. **닫는 괄호** `)`, `]`, `}`:
   - 스택이 비어있으면 → ❌
   - pop한 괄호와 짝이 맞는지 확인
   - 짝이 안 맞으면 → ❌
4. 순회 완료 후 스택이 비어있어야 함 → ✅

### 예시

```
입력: "([{}])"

Step 1: '(' → push ['(']
Step 2: '[' → push ['(', '[']
Step 3: '{' → push ['(', '[', '{']
Step 4: '}' → pop '{', 짝 확인 ✅ → ['(', '[']
Step 5: ']' → pop '[', 짝 확인 ✅ → ['(']
Step 6: ')' → pop '(', 짝 확인 ✅ → []

스택이 비어있음 → ✅ 올바른 괄호!
```

## 다른 풀이 방법

### 개선 포인트

**현재 코드:**
```typescript
if (char === "(" || char === "[" || char === "{")
```

**개선된 코드 (Set 사용):**
```typescript
const openBrackets = new Set(['(', '[', '{']);
const closeBrackets = new Set([')', ']', '}']);

if (openBrackets.has(char)) {
  stack.push(char);
}
else if (closeBrackets.has(char)) {
  // ...
}
```

**장점:** 더 많은 괄호 종류를 쉽게 추가 가능

## 배운 점 / 느낀 점

### 1. 스택(Stack) 자료구조의 이해

- **LIFO (Last In, First Out)**: 마지막에 들어간 게 먼저 나옴
- 괄호 검증에 스택이 완벽한 이유:
  - 가장 최근에 열린 괄호부터 닫혀야 함
  - 중첩된 구조를 자연스럽게 처리

### 2. 짝 맞추기 패턴

**객체로 매핑:**
```typescript
const pairs = {
  ")": "(",  // 닫는 괄호 → 여는 괄호
  "]": "[",
  "}": "{"
};
```

**왜 이 방향?**
- 닫는 괄호를 만났을 때 "어떤 여는 괄호와 짝인지" 찾기 위해
- `pairs[')']` → `'('` 빠르게 확인!

### 3. 중요한 실수들

**실수 1: 짝이 맞으면 바로 return**
```typescript
❌ if (top === pairs[char]) {
     return 1;  // 첫 괄호만 맞으면 끝!
   }

✅ if (top !== pairs[char]) {
     return 0;  // 안 맞을 때만 종료
   }
   // 맞으면 계속 진행!
```

**실수 2: 마지막 return 누락**
```typescript
❌ }  // 함수 끝 (return 없음!)

✅ return stack.length === 0 ? 1 : 0;
```

**실수 3: pairs 잘못 사용**
```typescript
❌ if (top !== pairs[top])  // top으로 찾기
✅ if (top !== pairs[char])  // char로 찾기
```

### 4. 엣지 케이스

- **빈 문자열**: `""` → 1 (괄호 없음 = 올바름)
- **괄호 없는 문자열**: `"int x = 42"` → 1
- **닫는 괄호만**: `")"` → 0 (스택이 비어서)
- **여는 괄호만**: `"("` → 0 (스택에 남음)

### 5. 실전 활용

**이 패턴이 쓰이는 곳:**
- 코드 에디터의 괄호 검증
- 컴파일러의 문법 검사
- HTML/XML 태그 검증
- 수식 계산기

### 6. 알고리즘 패턴

**"짝 맞추기 + 순서 보장" → 스택 사용!**
- 여는 것: push
- 닫는 것: pop + 확인
- 마지막에: 스택이 비었는지 확인

## 관련 개념

- 스택 (Stack)
- LIFO (Last In, First Out)
- 짝 맞추기 (Pair Matching)
