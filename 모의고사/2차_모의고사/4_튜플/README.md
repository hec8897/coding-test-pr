# 튜플

## 📌 문제 정보
- **레벨**: Lv.2
- **목표 시간**: 50분
- **개념**: 정렬, 문자열 파싱, Set

---

## 📝 문제 설명

셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다.  
n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.

- (a₁, a₂, a₃, ..., aₙ)

튜플은 다음과 같은 성질을 가지고 있습니다.

1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3. 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 `(a₁, a₂, a₃, ..., aₙ)`이 주어질 때,  
이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

```
{{a₁}, {a₁, a₂}, {a₁, a₂, a₃}, {a₁, a₂, a₃, a₄}, ... {a₁, a₂, a₃, a₄, ..., aₙ}}
```

예를 들어 튜플이 `(2, 1, 3, 4)`인 경우 이는

```
{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
```

와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

```
{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
{{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
{{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}
```

는 모두 같은 튜플 `(2, 1, 3, 4)`를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때,  
**s가 표현하는 튜플을 배열에 담아** return 하세요.

---

## 🎯 제한사항

- s의 길이는 5 이상 1,000,000 이하입니다.
- s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
- 숫자가 0으로 시작하는 경우는 없습니다.
- s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
- s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
- return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

---

## 📊 입출력 예

| s | result |
|---|--------|
| "{{2},{2,1},{2,1,3},{2,1,3,4}}" | [2, 1, 3, 4] |
| "{{1,2,3},{2,1},{1,2,4,3},{2}}" | [2, 1, 3, 4] |
| "{{20,111},{111}}" | [111, 20] |
| "{{123}}" | [123] |
| "{{4,2,3},{3},{2,3,4,1},{2,3}}" | [3, 2, 4, 1] |

### 입출력 예 설명

**예제 #1**
```
문자열 s: "{{2},{2,1},{2,1,3},{2,1,3,4}}"

파싱 결과:
[2]
[2, 1]
[2, 1, 3]
[2, 1, 3, 4]

길이 순으로 정렬 후 차이 찾기:
길이 1: [2] → 새로운 원소: 2
길이 2: [2, 1] → 새로운 원소: 1
길이 3: [2, 1, 3] → 새로운 원소: 3
길이 4: [2, 1, 3, 4] → 새로운 원소: 4

답: [2, 1, 3, 4]
```

**예제 #2**
```
문자열 s: "{{1,2,3},{2,1},{1,2,4,3},{2}}"

파싱 결과:
[1, 2, 3]
[2, 1]
[1, 2, 4, 3]
[2]

길이 순으로 정렬:
[2]           → 새로운 원소: 2
[2, 1]        → 새로운 원소: 1
[1, 2, 3]     → 새로운 원소: 3
[1, 2, 4, 3]  → 새로운 원소: 4

답: [2, 1, 3, 4]
```

---

## 💡 핵심 개념

### 1. 문자열 파싱

```typescript
// "{{2},{2,1},{2,1,3}}" → [[2], [2,1], [2,1,3]]

s = s.slice(2, -2);           // "2},{2,1},{2,1,3"
const groups = s.split("},{"); // ["2", "2,1", "2,1,3"]
const arrays = groups.map(g => g.split(",").map(Number));
```

### 2. 길이 순 정렬

```typescript
arrays.sort((a, b) => a.length - b.length);
```

### 3. 차이 찾기 (Set 활용)

```typescript
const result: number[] = [];
const used = new Set<number>();

for (const arr of arrays) {
  for (const num of arr) {
    if (!used.has(num)) {
      result.push(num);
      used.add(num);
    }
  }
}
```

---

## 🔑 풀이 전략

### 접근 방법
1. 문자열 파싱: 집합 기호 제거 및 분리
2. 각 집합을 배열로 변환
3. 길이 순으로 정렬
4. 작은 집합부터 순회하며 새로운 원소 찾기

### 핵심 아이디어
```
길이가 1인 집합: 튜플의 첫 번째 원소
길이가 2인 집합: 첫 번째 + 두 번째 원소
길이가 3인 집합: 첫 번째 + 두 번째 + 세 번째 원소
...

→ 이전 집합에 없던 원소가 다음 순서의 원소!
```

---

## 📝 단계별 풀이 예시

### 입력: "{{2},{2,1},{2,1,3},{2,1,3,4}}"

```typescript
// 1단계: 외부 중괄호 제거
"{{2},{2,1},{2,1,3},{2,1,3,4}}"
→ "{2},{2,1},{2,1,3},{2,1,3,4}"  // slice(1, -1)
아니면 "2},{2,1},{2,1,3},{2,1,3,4" // slice(2, -2)

// 2단계: },{ 로 분리
["2", "2,1", "2,1,3", "2,1,3,4"]

// 3단계: 각 문자열을 배열로 변환
[[2], [2,1], [2,1,3], [2,1,3,4]]

// 4단계: 길이 순 정렬 (이미 정렬됨)
[[2], [2,1], [2,1,3], [2,1,3,4]]

// 5단계: 차이 찾기
used = {}
[2]        → 2는 새로운 원소 → result = [2], used = {2}
[2,1]      → 1은 새로운 원소 → result = [2,1], used = {2,1}
[2,1,3]    → 3은 새로운 원소 → result = [2,1,3], used = {2,1,3}
[2,1,3,4]  → 4는 새로운 원소 → result = [2,1,3,4]

답: [2, 1, 3, 4]
```

---

## ⏱️ 시간 복잡도

- **파싱**: O(n) - 문자열 길이
- **정렬**: O(m log m) - m은 집합 개수
- **차이 찾기**: O(m × k) - k는 평균 집합 크기
- **전체**: O(n + m log m + m × k)

---

## 🎯 테스트 케이스

```typescript
console.log(solution("{{2},{2,1},{2,1,3},{2,1,3,4}}"));
// [2, 1, 3, 4]

console.log(solution("{{1,2,3},{2,1},{1,2,4,3},{2}}"));
// [2, 1, 3, 4]

console.log(solution("{{20,111},{111}}"));
// [111, 20]

console.log(solution("{{123}}"));
// [123]

console.log(solution("{{4,2,3},{3},{2,3,4,1},{2,3}}"));
// [3, 2, 4, 1]
```

---

## 🔍 주의사항

1. **문자열 파싱** 주의: 중괄호 개수 확인
2. **정렬** 필수: 길이 순으로 정렬해야 함
3. **Set 사용**: 이미 나온 원소 체크
4. **숫자 변환**: `map(Number)` 또는 `parseInt()`


